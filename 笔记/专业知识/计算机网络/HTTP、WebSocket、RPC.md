## Reference
- https://xiaolincoding.com/network/2_http/http_rpc.html
- https://xiaolincoding.com/network/2_http/http_websocket.html

## 为什么有了HTTP还需要WebSocket？

- TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。
## 为什么WebSocket比HTTP1.0性能好

WebSocket协议相较于HTTP协议在性能上的优势主要体现在以下几个方面，这些特性使其在实时通信和高频交互场景中表现更优：

### 1. **全双工通信与持久化连接**
WebSocket通过一次握手建立持久化的全双工连接，客户端和服务器可同时主动发送数据，无需像HTTP那样每次请求都重新建立TCP连接。例如，HTTP轮询需每秒多次发送请求头（含大量冗余信息），而WebSocket仅需一次握手后保持长连接，减少了90%以上的网络请求。这种机制显著降低了延迟，实测显示WebSocket延迟可降至毫秒级，而HTTP轮询延迟通常为秒级甚至更高。

### 2. **更小的协议开销**
WebSocket数据传输时头部仅需2-10字节（服务器到客户端）或额外4字节掩码（客户端到服务器），而HTTP每次请求需携带完整的头部（如Cookie、User-Agent等），导致带宽浪费。例如，频繁的HTTP轮询中，头部数据可能占传输总量的80%以上，而WebSocket有效数据占比更高。

### 3. **服务端主动推送能力**
HTTP遵循"请求-响应"模式，服务端无法主动推送数据，客户端需通过轮询（如每秒一次）获取更新，造成资源浪费。而WebSocket允许服务端实时推送数据（如聊天消息、股票行情），避免了轮询带来的延迟和冗余请求。实验表明，这一特性使实时应用响应速度提升10倍以上。

### 4. **高效的二进制支持**
WebSocket原生支持二进制帧传输，可直接处理图像、音视频等二进制数据，避免了HTTP中Base64编码/解码的性能损耗，传输效率提升约30%。相比之下，HTTP传输二进制数据需通过文本协议封装，增加了处理复杂度。

### 5. **服务器资源优化**
WebSocket的持久连接减少了TCP握手次数，降低了服务器处理连接的开销。研究表明，在高并发场景（如万人同时在线的游戏服务）中，WebSocket可减少80%的服务器资源消耗。而HTTP频繁建立/断开连接会导致TCP端口和内存资源快速耗尽。

### 性能对比案例
以在线聊天场景为例：
• **HTTP轮询**：每秒1次请求，每次500字节头部 + 50字节有效数据 → 24小时内消耗流量约 **47MB**
• **WebSocket**：建立连接后仅传输有效数据，相同场景下流量仅 **2.5MB**，且消息到达延迟从秒级降至50ms以内。

---
总结来看，WebSocket通过协议设计上的革新，在实时性、带宽利用率、服务器负载等核心指标上均优于HTTP，尤其适用于在线游戏、金融行情、IoT设备监控等对实时性要求高的领域。不过其持久连接特性也带来更高的服务器资源占用风险，需结合具体场景权衡选择。

## HTTP2.0 和 WebSocket 的区别？
| **特性​**​       | ​**​WebSocket​**​            | ​**​HTTP/2​**​              |
| -------------- | ---------------------------- | --------------------------- |
| ​**​通信模式​**​   | 全双工，双方可随时发送数据                | 单工，客户端发起请求后服务器响应            |
| ​**​连接管理​**​   | 单TCP连接保持开放，避免重复握手（降低延迟）      | 单TCP连接复用多个请求，减少连接数（提升效率）    |
| ​**​数据传输效率​**​ | 数据帧头部仅2-10字节，适合高频小数据包（如游戏指令） | 通过二进制分帧和头部压缩减少冗余（如网页资源加载）   |
| ​**​主动推送能力​**​ | 服务端可随时推送数据（无需客户端请求）          | 服务器推送需客户端先发起请求，且推送内容必须与请求相关 |
| ​**​协议复杂度​**​  | 协议简单，专注实时通信（易于实现）            | 支持流优先级、流量控制等复杂机制（适合大规模资源传输） |

## 为什么有了HTTP还需要RPC？
- 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。
- 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。
