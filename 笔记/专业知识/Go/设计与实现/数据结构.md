
## 切片
### 数据结构
- `Data` 是指向数组的指针;
- `Len` 是当前切片的长度；
- `Cap` 是当前切片的容量，即 `Data` 数组的大小
```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```
### 扩容策略
在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：
- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于 1024 就会将容量翻倍；
- 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；
```go
func growslice(et *_type, old slice, cap int) slice {
	newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.len < 1024 {
			newcap = doublecap
		} else {
			for 0 < newcap && newcap < cap {
				newcap += newcap / 4
			}
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
```
## 哈希表

重要概念：
- 哈希函数
- 冲突解决
	- 开放寻址法：数组
	- 拉链法：数组 + 链表

数据结构 hmap：
1. `count` 表示当前哈希表中的元素数量；
2. `B` 表示当前哈希表持有的 `buckets` 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 `len(buckets) == 2^B`；
3. `hash0` 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；
4. `oldbuckets` 是哈希在扩容时用于保存之前 `buckets` 的字段，它的大小是当前 `buckets` 的一半；
5. 
```go
type hmap struct {
	count     int
	flags     uint8
	B         uint8
	noverflow uint16
	hash0     uint32

	// 每个buckets能存储8个键值对，多出的放到溢出桶中（overflow）
	buckets    unsafe.Pointer
	oldbuckets unsafe.Pointer
	nevacuate  uintptr

	extra *mapextra
}

type mapextra struct {
	overflow    *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```

![image.png](https://happychan.oss-cn-shenzhen.aliyuncs.com/picgo/20250226190702.png)


### `bmap` 

```go
type bmap struct {
	tophash [bucketCnt]uint8
}

// 隐式生成的字段
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```

在 Go 语言的哈希表（`map`）实现中，`bmap` 是哈希桶的核心数据结构，其设计通过多维度优化实现高效的内存布局和访问性能。以下是其设计原理的详细解读：

#### 1. **动态内存布局：编译时确定的键值对结构**
`bmap` 的源代码定义看似仅包含 `tophash` 字段，但实际上其内存布局在编译时动态生成。具体包含：
- **`tophash`**：存储键的哈希值高 8 位，用于快速筛选键是否存在。
- **`keys` 和 `values` 数组**：分别存储 8 个键和值，键值分离排列以减少内存对齐浪费。
- **`overflow` 指针**：指向下一个溢出桶的地址，用于处理哈希冲突。

这种设计使得 `bmap` 能根据键值类型动态调整内存结构。例如，若键为 `int64`，值为 `int32`，编译时会生成对应的键值数组，无需在运行时进行类型判断。

---

#### 2. **`tophash` 的高效筛选机制**
- **哈希高位的快速比较**  
  `tophash` 存储哈希值的高 8 位，通过快速比较高位值，可初步过滤掉不匹配的键，避免频繁访问完整的键值对。例如，当查找一个键时，只需先比较哈希高位，若不一致则直接跳过该槽位。
- **状态标记功能**  
  `tophash` 还用于标记桶的状态，如空桶（`emptyRest`）、已迁移桶（`evacuated`）等，辅助扩容和垃圾回收。

---

#### 3. **内存对齐与紧凑存储**
- **键值分离存储**  
  键和值分别存储在独立数组中（而非交替存储），例如 `keys[8]` 和 `values[8]`。这种方式消除了键值类型不同导致的内存对齐浪费。例如，若键为 `int64`（8 字节）而值为 `bool`（1 字节），交替存储会因对齐填充浪费 7 字节，分离存储则完全避免此问题。
- **紧凑的溢出桶设计**  
  每个 `bmap` 最多存储 8 个键值对，超出时通过 `overflow` 指针链接到溢出桶，形成链表结构。这种设计减少了主桶的扩容频率，同时保持内存紧凑。

---

#### 4. **溢出桶的动态扩展**
- **链表式溢出处理**  
  当主桶的 8 个槽位已满时，新的键值对会被插入到溢出桶中。溢出桶与主桶通过 `overflow` 指针链接，形成一个单向链表。这种设计允许哈希表动态扩展，而无需立即触发全局扩容。
- **溢出桶的内存复用**  
  Go 在初始化时预分配一定数量的溢出桶（通过 `mapextra` 结构管理），减少运行时动态分配的开销。当预分配溢出桶用尽时，才会申请新的内存。

---

#### 5. **编译时优化的静态结构**
- **隐式字段的生成**  
  `bmap` 的完整结构（包括 `keys`、`values`、`overflow`）在编译时由编译器根据键值类型生成，而非显式定义在源代码中。例如，对于 `map[string]int`，编译器会生成包含 `string` 类型键和 `int` 类型值的 `bmap` 结构。
- **消除反射开销**  
  通过编译时静态生成代码，避免了运行时的反射操作，提升性能。

---

#### 总结
`bmap` 的设计通过以下核心思想实现高效性：
1. **空间效率**：键值分离存储、内存对齐优化、溢出桶的链表式扩展。
2. **时间效率**：`tophash` 快速筛选、编译时静态结构生成。
3. **动态扩展能力**：通过溢出桶避免频繁扩容，支持渐进式数据迁移。

这种设计使得 Go 的 `map` 在常数时间复杂度内完成增删改查操作，同时兼顾内存利用率，成为高性能哈希表的典范。

### 扩容策略

#### 条件
1. 装载因子已经超过 6.5；装载因子 = 元素数量 / 桶数量
2. 哈希使用了太多溢出桶；
#### 过程

##### 第一步：明确问题
**问题**：Golang 的哈希表（Map）是如何进行桶扩容的？

---

##### 第二步：用简单语言解释（假设对方是小白）
想象你有一个装苹果的箱子（桶），每个箱子最多放 8 个苹果。当箱子快满时，你需要更多箱子来装苹果。Golang 的哈希表扩容就像这个“换更大箱子”的过程，但具体怎么操作呢？

---

##### 第三步：核心概念拆解
1. **触发条件**  
   - **箱子太挤**（装载因子 > 6.5）：平均每个箱子里的苹果超过 6.5 个。  
   - **箱子太多空标签**（溢出桶过多）：虽然箱子没满，但挂了很多“备用箱子”（溢出桶），浪费空间。

2. **扩容类型**  
   - **翻倍扩容**：箱子数量翻倍（比如原来 4 个箱子变成 8 个）。  
   - **等量扩容**（SameSizeGrow）：箱子数量不变，但重新整理苹果，丢掉多余的“备用箱子”。

3. **渐进式迁移**  
   - 不是一次性搬完所有苹果，而是每次有人放/拿苹果时，顺手搬一点旧箱子里的苹果到新箱子。

---

##### 第四步：分步流程（类比生活场景）
**场景**：你有一个水果摊（哈希表），有 4 个箱子（桶），每个箱子最多放 8 个苹果（键值对）。

###### 1. **触发扩容**
- **情况一**：箱子平均装了 7 个苹果（超过 6.5）→ 需要翻倍到 8 个箱子。  
- **情况二**：虽然苹果不多，但箱子旁边挂了很多空备用箱（溢出桶）→ 重新整理到 4 个箱子，丢掉空箱。

###### 2. **准备新箱子**
- 如果是翻倍扩容：买 8 个新箱子，标号 0~7。  
- 如果是等量扩容：还是用 4 个箱子，但清理掉挂着的空箱。

###### 3. **搬苹果（数据迁移）**
- **翻倍扩容**：  
  - 旧箱子 0 的苹果，根据苹果的“身份证号”（哈希值）的最后一位是 0 还是 1，分到新箱子 0 或 4。  
  - 例如：苹果 A 的哈希值二进制是 `...100`，最后一位是 0 → 放到新箱子 0；苹果 B 的哈希值二进制是 `...101`，最后一位是 1 → 放到新箱子 4。

- **等量扩容**：  
  - 把旧箱子里的苹果重新整理，填满主箱子，减少挂着的备用箱。

###### 4. **边卖边搬（渐进式迁移）**
- 每次有顾客来买苹果（写/删操作），你顺手从旧箱子搬几个苹果到新箱子。  
- 顾客可能从旧箱子或新箱子拿苹果，但你会优先检查新箱子。

###### 5. **清理旧箱子**
- 当所有苹果都搬到新箱子后，丢掉旧箱子和挂着的空箱。

---

##### 第五步：检查漏洞
- **为什么翻倍扩容用哈希值的某一位？**  
  因为翻倍后箱子数是原来的 2 倍，相当于二进制多一位，用这一位决定苹果放到哪一半的新箱子。

- **等量扩容如何减少溢出桶？**  
  通过重新排列数据，让主箱子尽量装满，减少挂在旁边的溢出桶。

- **迁移期间读写会出错吗？**  
  不会！读操作会同时检查新旧箱子，写操作会触发部分迁移，保证数据一致性。

---

##### 第六步：总结
Golang 的哈希表扩容就像水果摊主根据客流量动态调整箱子数量，通过“翻倍换大箱”或“整理旧箱”，边营业边搬运，既保证生意不停，又能高效管理库存。