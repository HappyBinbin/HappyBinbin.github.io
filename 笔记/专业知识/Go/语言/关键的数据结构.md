
## 切片
### 数据结构
- `Data` 是指向数组的指针;
- `Len` 是当前切片的长度；
- `Cap` 是当前切片的容量，即 `Data` 数组的大小
```go
type SliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}
```
### 扩容策略
在分配内存空间之前需要先确定新的切片容量，运行时根据切片的当前容量选择不同的策略进行扩容：
- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于 1024 就会将容量翻倍；
- 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；
```go
func growslice(et *_type, old slice, cap int) slice {
	newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
		if old.len < 1024 {
			newcap = doublecap
		} else {
			for 0 < newcap && newcap < cap {
				newcap += newcap / 4
			}
			if newcap <= 0 {
				newcap = cap
			}
		}
	}
```
## 哈希表

重要概念：
- 哈希函数
- 冲突解决
	- 开放寻址f法
	- 拉链法

数据结构 hmap：
1. `count` 表示当前哈希表中的元素数量；
2. `B` 表示当前哈希表持有的 `buckets` 数量，但是因为哈希表中桶的数量都 2 的倍数，所以该字段会存储对数，也就是 `len(buckets) == 2^B`；
3. `hash0` 是哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定，并在调用哈希函数时作为参数传入；
4. `oldbuckets` 是哈希在扩容时用于保存之前 `buckets` 的字段，它的大小是当前 `buckets` 的一半；
5. 
```go
type hmap struct {
	count     int
	flags     uint8
	B         uint8
	noverflow uint16
	hash0     uint32

	// 每个buckets能存储8个键值对，多出的放到溢出桶中（overflow）
	buckets    unsafe.Pointer
	oldbuckets unsafe.Pointer
	nevacuate  uintptr

	extra *mapextra
}

type mapextra struct {
	overflow    *[]*bmap
	oldoverflow *[]*bmap
	nextOverflow *bmap
}
```

![image.png](https://happychan.oss-cn-shenzhen.aliyuncs.com/picgo/20250226190702.png)


### `bmap` 

```go
type bmap struct {
	tophash [bucketCnt]uint8
}

// 隐式生成的字段
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```

在 Go 语言的哈希表（`map`）实现中，`bmap` 是哈希桶的核心数据结构，其设计通过多维度优化实现高效的内存布局和访问性能。以下是其设计原理的详细解读：

#### 1. **动态内存布局：编译时确定的键值对结构**
`bmap` 的源代码定义看似仅包含 `tophash` 字段，但实际上其内存布局在编译时动态生成。具体包含：
- **`tophash`**：存储键的哈希值高 8 位，用于快速筛选键是否存在。
- **`keys` 和 `values` 数组**：分别存储 8 个键和值，键值分离排列以减少内存对齐浪费。
- **`overflow` 指针**：指向下一个溢出桶的地址，用于处理哈希冲突。

这种设计使得 `bmap` 能根据键值类型动态调整内存结构。例如，若键为 `int64`，值为 `int32`，编译时会生成对应的键值数组，无需在运行时进行类型判断。

---

#### 2. **`tophash` 的高效筛选机制**
- **哈希高位的快速比较**  
  `tophash` 存储哈希值的高 8 位，通过快速比较高位值，可初步过滤掉不匹配的键，避免频繁访问完整的键值对。例如，当查找一个键时，只需先比较哈希高位，若不一致则直接跳过该槽位。
- **状态标记功能**  
  `tophash` 还用于标记桶的状态，如空桶（`emptyRest`）、已迁移桶（`evacuated`）等，辅助扩容和垃圾回收。

---

#### 3. **内存对齐与紧凑存储**
- **键值分离存储**  
  键和值分别存储在独立数组中（而非交替存储），例如 `keys[8]` 和 `values[8]`。这种方式消除了键值类型不同导致的内存对齐浪费。例如，若键为 `int64`（8 字节）而值为 `bool`（1 字节），交替存储会因对齐填充浪费 7 字节，分离存储则完全避免此问题。
- **紧凑的溢出桶设计**  
  每个 `bmap` 最多存储 8 个键值对，超出时通过 `overflow` 指针链接到溢出桶，形成链表结构。这种设计减少了主桶的扩容频率，同时保持内存紧凑。

---

#### 4. **溢出桶的动态扩展**
- **链表式溢出处理**  
  当主桶的 8 个槽位已满时，新的键值对会被插入到溢出桶中。溢出桶与主桶通过 `overflow` 指针链接，形成一个单向链表。这种设计允许哈希表动态扩展，而无需立即触发全局扩容。
- **溢出桶的内存复用**  
  Go 在初始化时预分配一定数量的溢出桶（通过 `mapextra` 结构管理），减少运行时动态分配的开销。当预分配溢出桶用尽时，才会申请新的内存。

---

#### 5. **编译时优化的静态结构**
- **隐式字段的生成**  
  `bmap` 的完整结构（包括 `keys`、`values`、`overflow`）在编译时由编译器根据键值类型生成，而非显式定义在源代码中。例如，对于 `map[string]int`，编译器会生成包含 `string` 类型键和 `int` 类型值的 `bmap` 结构。
- **消除反射开销**  
  通过编译时静态生成代码，避免了运行时的反射操作，提升性能。

---

#### 总结
`bmap` 的设计通过以下核心思想实现高效性：
1. **空间效率**：键值分离存储、内存对齐优化、溢出桶的链表式扩展。
2. **时间效率**：`tophash` 快速筛选、编译时静态结构生成。
3. **动态扩展能力**：通过溢出桶避免频繁扩容，支持渐进式数据迁移。

这种设计使得 Go 的 `map` 在常数时间复杂度内完成增删改查操作，同时兼顾内存利用率，成为高性能哈希表的典范。

### 扩容策略

哈希的扩容：
1. 装载因子已经超过 6.5；
2. 哈希使用了太多溢出桶；