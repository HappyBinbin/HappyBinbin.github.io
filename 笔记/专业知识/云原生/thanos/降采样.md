时序数据的降采样是指将频率较高的时序数据降低到较低频率的时序数据的过程。
降采样可以减少数据量从而延长存储时间，提升查询速度，同时尽可能地保留原始数据的趋势和特征。日志服务的降采样通过将时间序列中的数据点进行特定算法的分组与聚合来实现。

注意：降采样本身并不会减少存储空间
## 降采样原理
![Pasted image 20250808100616.png](https://happychan.oss-cn-shenzhen.aliyuncs.com/picgo/Pasted%20image%2020250808100616.png)
## Thanos

Thanos 是 Prometheus 的高可用方案；主要有两种部署形式：
### Sidecar
在每一个 Prometheus 节点旁边部署一个 thanos sidecar，将prometheus本地的tsdb数据同步到对象存储中；

![image.png](https://happychan.oss-cn-shenzhen.aliyuncs.com/picgo/20250810140723.png)
### Receiver
提供一个统一的 receiver 接受所有来源的数据写入对象存储；
![image.png](https://happychan.oss-cn-shenzhen.aliyuncs.com/picgo/20250810140752.png)


## 降采样

thanos 的降采样核心逻辑在 pkg/compact/downsample，集成在 thanos compact 组件中；

> 局限性：只有配置了对象存储，才能使用 thanos compact 能力；


### 降采样的默认查询

当查询降采样后的aggrchunk时，promql中没有指定聚合函数，Thanos Querier会默认请求 COUNT 和 SUM 聚合块，用来计算计算平均值；
``` go
// aggrsFromFunc infers aggregates of the underlying data based on the wrapping
// function of a series selection.
func aggrsFromFunc(f string) []storepb.Aggr {
	if f == "min" || strings.HasPrefix(f, "min_") {
		return []storepb.Aggr{storepb.Aggr_MIN}
	}
	if f == "max" || strings.HasPrefix(f, "max_") {
		return []storepb.Aggr{storepb.Aggr_MAX}
	}
	if f == "count" || strings.HasPrefix(f, "count_") {
		return []storepb.Aggr{storepb.Aggr_COUNT}
	}
	// f == "sum" falls through here since we want the actual samples.
	if strings.HasPrefix(f, "sum_") {
		return []storepb.Aggr{storepb.Aggr_SUM}
	}
	if f == "increase" || f == "rate" || f == "irate" || f == "resets" || f == "xincrease" || f == "xrate" {
		return []storepb.Aggr{storepb.Aggr_COUNTER}
	}
	// In the default case, we retrieve count and sum to compute an average.
	return []storepb.Aggr{storepb.Aggr_COUNT, storepb.Aggr_SUM}
}
```

### 当前窗口计算

``` go
// currentWindow returns the end timestamp of the window that t falls into.
func currentWindow(t, r int64) int64 {
	// The next timestamp is the next number after s.t that's aligned with window.
	// We subtract 1 because block ranges are [from, to) and the last sample would
	// go out of bounds otherwise.
	return t - (t % r) + r - 1
}
```

假设分辨率 r 为 5 分钟（300,000 毫秒），时间戳 t 为 1,620,000,001 毫秒：
- 计算 t % r 得到 1 毫秒
- 计算 t - (t % r) 得到 1,620,000,000 毫秒（当前窗口起始时间）
- 加上 r 得到 1,620,300,000 毫秒（下一个窗口起始时间）
- 减 1 得到 1,620,299,999 毫秒（当前窗口结束时间）
这确保了时间窗口  `[1,620,000,000, 1,620,300,000)` 内的所有样本都被正确包含在当前窗口中。

currentWindow 函数的设计是为了满足降采样过程中时间窗口对齐、区间表示适配、批次划分、防止重叠和支持聚合逻辑的需求。通过将时间戳准确对齐到窗口边界，并适配左闭右开的区间表示，确保了降采样数据的准确性和一致性。

## 数据聚合器

### 浮点数聚合器

该方法接收一个样本点 s ，并根据样本值和历史状态更新聚合器的内部状态，包括计数器值、总和、计数、最大值、最小值等。
关键变量说明
- a.total : 已处理的总样本数
- a.counter : 计数器值，用于累计计算
- a.resets : 计数器重置次数
- a.last : 上一个样本的值
- a.sum : 所有样本值的总和
- a.count : 当前聚合窗口内的样本数
- a.min / a.max : 样本中的最小值/最大值

``` go
func (a *floatAggregator) add(s sample) {
	if a.total > 0 {
		if s.v < a.last {
			// Counter reset, correct the value.
			a.counter += s.v
			a.resets++
		} else {
			// Add delta with last value to the counter.
			a.counter += s.v - a.last
		}
	} else {
		// First sample sets the counter.
		a.counter = s.v
	}
	a.last = s.v

	a.sum += s.v
	a.count++
	a.total++

	if s.v < a.min {
		a.min = s.v
	}
	if s.v > a.max {
		a.max = s.v
	}
}
```

设计意义
1. 计数器重置检测 : 该方法能够自动检测计数器重置事件(如服务重启导致的计数器归零)，并通过 resets 字段记录，确保聚合结果的准确性
2. 增量计算 : 对于正常增长的计数器，通过计算增量( s.v - a.last )而非直接累加，避免重复计数
3. 多维度统计 : 同时维护总和、计数、最大/最小值等多种统计指标，为降采样提供全面的数据支持
4. 状态维护 : 通过维护 last 和 total 等状态变量，确保跨批次样本处理的连续性

