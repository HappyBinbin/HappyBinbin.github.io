# 13. 客户端

Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，处理他们的请求。

通过使用**由I/O多路复用技术实现的文件事件处理器**，Redis服务器使用**单线程单进程的方式**来处理命令请求，并与多个客户端进行网络通信。

对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的`redis.h/redisClient`结构（**客户端状态**），这个结构保存了客户端**当前的状态信息**。

在服务器中，用一个**链表**保存客户端的所有状态

```c
struct redisServer 
{ 
    // ... 
    // 一个链表，保存了所有客户端状态 
    list *clients; 
    // ...
};
```

[![img](https://camo.githubusercontent.com/69c535555b3c44d8bcf2e221313a887247e65960bbb851f0423a8e04885eaf7d/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363130323032352e706e67)](https://camo.githubusercontent.com/69c535555b3c44d8bcf2e221313a887247e65960bbb851f0423a8e04885eaf7d/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363130323032352e706e67)

## 13.1 客户端的属性

客户端的属性分为两类：

- 比较通用属性，这些属性很少与特定功能相关，无论客户端执行的是什么工作，他们都要用到这些属性
- 和特定功能相关的属性

### 13.1.1 套接字描述符

客户端状态的fd属性记录了客户端**正在使用的套接字描述符**。根据客户端类型不同，fd的值可以是**-1或大于-1的整数**：

- 伪客户端为-1：伪客户端用于处理的AOF文件或Lua脚本，**而不是网络**。
- 普通客户端为大于-1的整数。

执行CLIENT list命令会列出所有连接到服务器的普通客户端。

```sql
redis> CLIENT list
addr=127.0.0.1:53428 fd=6 name= age=1242 idle=0 ...
addr=127.0.0.1:53469 fd=7 name= age=4 idle=4 ...
```

### 13.1.2 名字

默认情况下客户端是没有名字的，比如上面的例子中name处就是空白。使用**CLIENT setname**命令可以为客户端设置一个名字，让客户端的身份变得更清晰。

```c
typedef struct redisClient
{
    //...
    robj *name;
    //...
}redisClient;
```

如果客户端没有名字，那么相应客户端状态的name属性指向NULL指针；相反，如果有名字，那么name属性将指向一个字符串对象。

### 13.1.3 标志

客户端的标志属性flags记录了客户端的角色（role），以及客户端目前所处的状态：

```c
typedef struct redisClient 
{ 
    // ... 
    int flags; 
    // ...
} redisClient;
```

比如`REDIS_BLOCKED`标志表示客户端正在被BRPOP、BLPOP等命令阻塞。flag可以是单个标志，也可以是多个标志的组合。比如：

```
flags=REDIS_SLAVE | REDIS_PRE_PSYNC;
```

其他的标志就不多赘述，可以查看官方文档或者书本P165-167页

### 13.1.4 输入缓冲区

客户端状态的输入缓冲区用于**保存客户端发送的命令请求**：

```c
typedef struct redisClient 
{ 
    // ... 
    sds querybuf; 
    // ...
} redisClient;
```

保存方式和AOF类似，比如`SET key value`被转化为如下的SDS值：

```
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
```

[![img](https://camo.githubusercontent.com/f2f73d27703684ab9406f044f4c3f33db2d016422e772b41de9f795885590819/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363130353833312e706e67)](https://camo.githubusercontent.com/f2f73d27703684ab9406f044f4c3f33db2d016422e772b41de9f795885590819/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363130353833312e706e67)

### 13.1.5 命令与命令参数

在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行**分析**，并将得出的**命令参数**以及**命令参数的个数**分别保存到客户端状态的**argv属性**和**argc属性**：

```c
typedef struct redisClient 
{ 
    // ... 
    robj **argv;
    int argc;
    // ...
} redisClient;
```

argv属性是一个数组，**数组中的每个项都是一个字符串对象**，其中`argv[0]`是**要执行的命令**，而之后的其他项则是**传给命令的参数**。

[![img](https://camo.githubusercontent.com/74367cbdb2b54752f10d3ff6666e771c209d67d6a4117daefbab40d6ba46e102/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363131303232332e706e67)](https://camo.githubusercontent.com/74367cbdb2b54752f10d3ff6666e771c209d67d6a4117daefbab40d6ba46e102/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363131303232332e706e67)

### 13.1.6 命令的实现函数

当服务器从协议内容中分析并得出argv属性和argc属性的值之后，服务器**将根据项argv[0]的值，在命令表中查找命令所对应的命令实现函数。**

命令表是一个字典结构，键是SDS结构，保存了命令的名字，**值是redisCommand结构**，保存了：

- 实现函数
- 命令标志
- 命令的参数个数
- 命令的总执行次数
- 总消耗时长

当程序在命令表中成功找到argv[0]所对应的redisCommand结构时，**客户端状态的cmd指针指向这个结构**：

```c
typedef struct redisClient 
{ 
    // ... 
    struct redisCommand *cmd;
    // ...
} redisClient;
```

服务器就可以使用cmd属性所指向的redisCommand结构，以及argv、argc属性中保存的命令参数信息，调用命令实现函数，执行客户端指定的命令。

[![img](https://camo.githubusercontent.com/6ef729c9570c623efe3ab8f72b0e8d108e0e0430cc77a7c4dd7fd87b1ea5f142/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363131343232322e706e67)](https://camo.githubusercontent.com/6ef729c9570c623efe3ab8f72b0e8d108e0e0430cc77a7c4dd7fd87b1ea5f142/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130363131343232322e706e67)

### 13.1.7 输出缓冲区

**命令回复**会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个输出缓冲区可用，**一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的**：

#### 固定大小的缓冲区

缓冲区由一个默认为16KB的字节数组和一个记录已使用字节数量的整数组成，用于**保存那些长度比较小的回复**，比如OK、简短的字符串值、整数值、错误回复等等。

#### 可变大小的缓冲区

由reply链表和一个或多个字符串独享组成，用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个由很多项组成的列表，一个包含了很多元素的集合等等。

### 13.1.8 身份验证

客户端状态的**authenticated**属性用于记录客户端是否通过了身份验证：

```c
typedef struct redisClient 
{ 
    // ... 
    int authenticated;
    // ...
} redisClient;
```

为0表示没有通过验证，为1表示通过。如果没有通过，**除了AUTH命令之外，客户端发送的所有其他命令都会被服务器拒绝执行**。

```sql
redis> SET msg "hello world"
(error) NOAUTH Authentication required.
```

当客户端通过AUTH命令成功进行身份验证之后，客户端状态authenticated属性的值就会从0变为1.

### 13.1.9 时间

客户端还有几个和时间有关的属性：

```c
typedef struct redisClient 
{ // ... 
    time_t ctime; 
    time_t lastinteraction; 
    time_t obuf_soft_limit_reached_time; // ...
} redisClient;
```

- ctime属性记录了创建客户端的时间，这个时间可以用来计算客户端与服务器已经连接了多少秒。
- lastinteraction属性记录了客户端与服务器最后一次进行互动（interaction）的时间。（收或者发命令）
- obuf_soft_limit_reached_time属性记录了输出缓冲区第一次到达软性限制（soft limit）的时间

## 13.2 创建和关闭客户端

### 13.2.1 普通客户端

所谓普通客户端是**指客户端通过网络与服务器连接**，客户端使用connect函数连接到服务器时就会**调用连接事件处理器**。

之后，会将新客户端的状态添加到clients链表的末尾。

关闭的原因可能有很多种

- 客户端进程退出或被杀死
- 客户端向服务器发送了带有不符合协议格式的命令请求
- 如果客户端成为了CLIENT KILL命令的目标
- 客户端空转超时
- 客户端发送的命令请求的大小超过了输入缓冲区的限制大小（默认为1 GB）
- 如果要发送给客户端的命令回复的大小超过了输出缓冲区的限制大小

除了不得超过1GB大小的**硬性限制**外，还有**软性限制**，用到了之前提到的`obuf_soft_limit_reached_time`属性。

如果输出缓冲区的大小超过了软性限制所设置的大小，但还没超过硬性限制，那么服务器将使用客户端状态结构的`obuf_soft_limit_reached_time`属性记录下客户端到达软性限制的起始时间。之后服务器会继续监视客户端，**如果输出缓冲区的大小一直超出软性限制，并且持续时间超过服务器设定的时长，那么服务器将关闭客户端**

### 13.2 Lua脚本的伪客户端

服务器会在**初始化时**创建负责执行Lua脚本中包含的Redis命令的伪客户端，并将这个伪客户端关联在服务器状态结构的lua_client属性中：

```c
struct redisServer 
{ 
    // ... 
    redisClient *lua_client; 
    // ...
};
```

Lua脚本会一直存在于服务器生命周期，只有服务器被关闭时他才会停止。

服务器在载入AOF文件时，会创建用于执行AOF文件包含的Redis命令的伪客户端，并在载入完成之后，关闭这个伪客户端。























