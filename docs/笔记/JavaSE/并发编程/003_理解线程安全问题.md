# 理解线程安全问题

1. 如何理解并行和并发？
2. 何为竞态 Race Condition？
3. 理解竞态的两种模式？
4. 如何预防竞态？



## 1、如何理解并行和并发？

- 如果1个CPU同时执行5个任务，就是**并发**
- 如果5个CPU同时执行5个任务，并且是每个CPU执行一个，那么就是**并行**

## 2、何为竞态 Race Condition？

**所谓竞态，可以理解为多个线程试图在同一时刻修改共享数据的情况**。从字面上理解的话，**Race**这个词就是**比赛**的意思。比赛的目标是什么？是看谁先获得共享资源，即进入**临界区（Critical Section）**。

## 3、理解竞态的两种模式？

```java
public class Master {
    //主宰的初始血量
    private int blood = 100;

    //每次被击打后血量减5
    public int decreaseBlood() throws Exception {
        if(blood <= 0){
            throw new Exception("主宰已经被击败！");
        }
        blood = blood - 5;
        return blood;
    } 
}
```

上面这段代码，在两种竞态模式下，会引发不同的错误

### Read-modify-write

- 第一步：从内存中读取`blood`的值到寄存器（**Read**）
- 第二步：修改寄存器中的`blood`值（**Modify**）
- 第三步：将寄存器的值写回内存（**Write**）

如果在第一步时，两个线程同时都读取到了值（比如100），随后两个线程同时做了修改，此时在第三步，无论是哪个线程率先将值写回内存，后面的线程都会**覆盖**内存中的值。换句话说，主宰承受了两次攻击，血量应该降低到90，可结果却是95，不是它耐操，而是你代码写错了！

### Check-then-act

- 第一步：线程A和线程B检查血量是否为 *0* （**Check**）
- 第二步：线程A和线程B都通过了检查
- 第三步：线程A和线程B执行血量扣减动作，但顺序未知（**Act**

如果线程A在执行`blood = blood - 5`时，`blood`的值不再是 *5* ，而是已经被线程B更改为 *0* 了呢？那么结果就是主宰最后的血量是 *-5* ！很显然，这样的结果就扯淡了。

简单来说， **Read-modify-write**是在写入时因并发导致值被**覆盖**，而**Check-then-act**则是因并发导致**条件判断失效**

## 4、如何预防竞态？

既然多线程是不安全的，那如何预防竞态的发生？其核心在于**锁+原子操作**，即**对临界区进行加锁，让临界区每次有且只能有一个线程访问**，在当前线程未离开临界区时，其他线程不得进入，且线程在临界区的操作必须保证原子性。

在Java中，最简单的加锁方式是使用`synchronized`关键字