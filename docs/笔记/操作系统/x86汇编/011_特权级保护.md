# 特权级保护

80386CPU为了给操作系统提供硬件级的可靠保护，提供了特权级保护功能。80386处于保护模式时，会改变CPU的行为方式，其中便包括开启特权级保护。实现良好的特权级保护是需要软硬件相协调的，CPU提供硬件机制的同时也需要与操作系统相配合，共同实现完善的特权级保护功能

# 1. 全局描述符表GDT

## 1.1 段描述符与描述符表

在8086中，为了让程序能在内存中浮动地加载装配，通过段地址和段内偏移地址共同组成最终的物理地址

在保护模式中，段机制依然存在，为了支持特权机保护，在一个段能够被访问之前，需要先进行“登记注册”

用于登记注册的一个段详细信息的数据结构被称为**段描述符**，固定为8个字节，64位，在一个多任务系统中会定义很多不同的段，一个段就对应着一个段描述符，为了统一的进行管理，需要在内存中开辟一段连续的空间集中紧密相连的描述符，而这一段连续的内存空间被称为描述符表（除了段描述符，还有门描述符，默认描述符等）

描述符表有多种类型，如：全局描述符表 GDT、局部描述符表 LDT，中断描述符表 IDT 等



## 1.2 全局描述符表的定义

全局描述符表（Global Descriptor Table，GDT）是最主要的描述符表，在进入保护模式之前，必须定义全局描述符表

理论上，GDT可以位于内存中的任何地方，但是初始设置的GDT一般位于1MB以下的内存范围内，这是因为设置初始GDT是在进入保护模式之前，而在进入保护模式之前，处理器只能访问1MB以下的内存空间

- 说明1：允许在进入保护模式之后，重新定义GDT

- 说明2：GDT表不是由用户程序自己建立的，而是在加载用户程序时，由操作系统根据用户程序的结构建立的，而用户程序通常无法建立和修改GDT，处理器借此实现保护功能




## 1.3 全局描述符表寄存器GDTR

![img](https://img-blog.csdnimg.cn/20210609144851944.png)



### 1.3.1 GDTR用途

为了跟踪GDT，处理器内部设置了一个48位的GDTR寄存器，同时提供了lgdt指令用于将GDT信息加载到GDTR中

GDT与GDTR的关系如下图所示，

![image-20220402113612274](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021136359.png)



### 1.3.2 GDTR构成

#### 32位GDT线性基地址

对于32位的处理器，GDTR中32位的线性基地址确保可以将GDT部署在4GB范围内的任何位置

#### 16位边界值

GDT边界值 = 表内最后一个字节相对于表开始处的偏移量，在数值上为表的总字节数减1

16位的边界值最大为65535，因此表的总字节数为65536。又因为每个段描述符需要8B，因此GDT表中最多可以定义（65536 / 8 = 8192）个描述符

说明：预留一个伏笔，由于GDT表中最多可以有8192个描述符，那么索引这些描述符就需要至少13位（详见段选择符的构成）

![image-20220402113629165](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021136230.png)

### 1.3.3 lgdt指令

lgdt指令用于将GDT表的基地址和界限值加载到GDTR中，指令格式如下，	

```assembly
lgdt m48
```

这里m48表示该指令的操作数是一个48位的内存区域，且要求低16位为GDT界限值，高32位是GDT线性基地址

![image-20220402113030497](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021130150.png)



- 说明1：lgdt指令在实模式和保护模式下均可执行

- 说明2：对于m48这个内存地址的有效地址（EA）的给出方式，在16位实模式下，EA是16位的；在32位保护模式下，EA是32位的

- 说明3：lgdt指令不影响任何标志位



# 2. 局部描述符表 LDT

现代的操作系统是多任务的，那么什么是任务呢？

**程序是保存在存储介质中的指令和数据的结合体，而正在执行程序的一个副本就是任务。**一个程序可以有运行在内存中的多个副本，每个副本都是一个任务。支持多任务的操作系统要让并发的多个任务和谐共处，就需要在任务之间通过一些手段令不同任务间彼此隔离。一般情况下，不同任务之间的内存是不互通的，每个任务都有自己的内存空间，一个任务不能随意访问另一个任务独有的内存空间

80386CPU的设计者建议为每个任务分配独有的描述符表，**这一描述符表被称为局部描述符表LDT。**每个任务私有的内存段，其段描述符不放在GDT中，而是放在LDT中

CPU通过可以通过GDTR寄存器来找到GDT所在的位置。同样的，80386提供了局部描述符表寄存器(**Local Descripter Table Register LDTR**)来追踪LDT的位置

和GDT不同的是，每个任务都有着自己的LDT。在多任务轮流执行的多任务系统中，正在执行的任务被成为当前任务，而LDTR则指向当前任务的LDT。任务切换时，LDTR中的数据会发生变化，指向新的当前任务



# 3. 存储器段描述符详解

![image-20211115192751797](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20211115192751797.png)



存储器段描述符格式如上图所示，下面逐一说明其中的字段

描述符不是用户自己建立的，而是用户程序被操作系统加载时，有操作系统根据用户程序的结构而建立的。用户程序是无法自己修改和建立GDT的

用户程序只能老老实实的在自己的地盘上工作。这个时候操作系统为用户程序建立了几个段（定义了几个段描述符），用户程序就只能在这些段内工作，超出这个范围，或者未按预定的方法访问这些段，都将被处理器阻止



## 3.1 段基地址

① 段基地址为32位，确保段基址可以是0 ~ 4GB范围内的任意地址

② 32位段基地址分段保存，是源于80286处理器的历史遗留问题

说明：虽然段基地址可以是0 ~ 4GB范围内的任意地址，而且Intel处理器也允许地址不对齐访问。但是还是建议选取16B对齐的地址作为段基址，因为对齐可以使程序在访问代码和数据时的性能最大化



## 3.2 段界限

① 20位的段界限用来限制段的扩展范围，越过段界限的访问将被处理器阻止并触发异常

② 对于向上扩展的段，偏移量从0开始递增，段界限决定了偏移量的最大值（包含该值）

![image-20220402113832291](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021138374.png)



由于偏移量从0开始，所以（段界限 + 1）就是段的大小。因此，如果指定的段界为0，则段的大小为1

③ 对于向下扩展的段，段界限决定了偏移量的最小值（不包含该值）。段界限是偏移量所不允许的最小值，小于或等于就会触发异常。

![image-20220402113837727](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021138775.png)



段的大小为0xFFFF或0xFFFFFFFF到设置的段界限处，这里之所以分为16位和32位的偏移量最大值，是因为偏移量可能是16位寄存器提供的（e.g. 使用SP指针），也可能是32位寄存器提供的（e.g. 使用ESP寄存器）

如果指定的段界限为0，此时段的大小是最大的

- 说明1：向下扩展的段不一定用作栈段，但是通常用作栈段

- 说明2：使用向下扩展的段作为栈段的缺点


向下扩展的段的段内偏移量最大值一定是0xFFFF或0xFFFFFFFF，而SP或ESP寄存器一般并不设置为该值。但是即使不使用0xFFFF（FFFF）到SP（ESP）之间的范围，这段内存也包含在当前段中

![image-20220402113846939](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021138996.png)





## 3.3 G位粒度（Granularity）位

① 粒度用于解释段界限的单位

② 当G = 0，段界限以字节为单位；当G = 1，段界限以4KB为单位



## 3.4 S位类型位

① S位用于指定描述符的类型（Descriptor Type）

② 当S = 0，表示是一个系统描述符，且TYPE字段用来指定系统段的类型或门的类型

③ 当S = 1，表示是一个存储器的段描述符，且TYPE字段用来区分代码段和数据段（栈段也是特殊的数据段）

说明1：描述符的分类

![image-20220402114047685](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021140770.png)



其中系统描述符有如下类型

![image-20220402114059488](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/202204021140561.png)





说明2：处理器对描述符的处理过程

处理器拿到描述符后，先根据S位判断其分类，然后根据TYPE字段得到子类型，之后解析描述符的其他字段



## 3.5 DPL描述符特权级

DPL字段(Descriptor Privilege Level)代表当前段描述符的特权级,占两bit位。

　　80386共支持4种特权级级别，分别是0,1,2,3。数字越小，特权级越高，0代表最高特权级，3代表最低特权级



① DPL表示描述符的特权级（Descriptor Privilege Level），指定要访问该段所必须具有的最低特权级

② 处理器共有4种特权级别，分别为0（最高特权级别）、1、2、3（最低特权级别）。刚进入保护模式时执行的代码具有最高特权级，可以看成是从处理器那里继承来的

③ 基于特权级的保护体现在如下2个方面

a. 不同特权级别的程序是相互隔离的，其互访是严格限制的

b. 有些处理器指令（特权指令）只能由0特权级的程序来执行



说明：为何CS寄存器的上电初始值为0xF000 ?

8086处理器[CS : IP]寄存器的初始值为[0xFFFF : 0x0000]，但是后续的X86处理器将上电初始值修改为[0xF000 : 0xFFF0]

修改前后，处理器上电后访问的第1条指令的地址是相同的，该修改就是为了兼容后续X86处理器引入的特权级模式

修改之后的CS寄存器初值为0xF000，当进入保护模式时，CS将被作为段选择器，其中的最低2位作为CPL，此时CPL = 0，为最高特权级，可以跳转到0特权级的操作系统代码中运行

如果不修改，当进入保护模式时，CPL = 3，为最低特权级，将无法跳转到0特权级的操作系统代码中运行



## 3.6 P位存在（Present）位

① P位用于指示描述符对应的段是否在内存中



② P位为0的2种情况，

a. 当内存紧张时，可能创建了段描述符，但是尚未准备对应的内存空间

b. 当内存紧张时，将不常使用的段交换到硬盘上，此时需要将P位置为0



③ P位由处理器负责检查，每当通过描述符访问内存中的段时，如果P位为0，处理器会差生一个异常中断。该中断对应的中断处理程序通常由操作系统提供，用于将该段从硬盘换回内存，并将P位置为1



说明1：这里描述的是以段为交换单位的虚拟内存管理机制，由于以段为单位进行交换性能消耗较大且容易导致内存碎片，后续被以页为单位的交换机制替代



说明2：一个段是否常用的标准，就需要依靠段描述符中TYPE字段中的A位（详见下文）



## 3.7 D/B位操作数大小位

① D/B位有3种功能，

a. 默认的操作数大小（Default Operation Size）标志

b. 默认的栈指针大小（Default Stack Pointer Size）标志

c. 栈上部边界（Upper Bound）标志



② D/B位的设立，主要是为了能够在32位处理器上兼容运行16位保护模式的程序（这种程序已经非常罕见，我们不做讨论）



③ 该标志对不同的段有不同的效果

a. 对于代码段，此位称作D位，用于指示指令中默认的偏移地址和操作数尺寸，其中D = 0表示默认16位；D = 1表示默认32位

e.g. 如果代码段的D位为0，处理器在该段上执行时，将使用IP寄存器，而不是EIP寄存器



b. 对于栈段，此位称作B位，用于在进行隐式的栈操作时，是使用SP寄存器还是ESP寄存器

同时，B位也决定了栈的上部边界，如果B = 0，那么栈段的上部边界为0xFFFF；如果B = 1，那么栈段的上部边界为0xFFFFFFFF



说明1：此处的栈段，更准确的说是向下扩展的数据段

说明2：在本课程中，D/B位均设置为1，不讨论16位保护模式的情况



## 3.8 L位64位代码段标志位

① L（Long mode, 64-bit Code Segment）位是64位代码段标志，保留此位给64位处理器使用

② 本课程中，讨论32位保护模式，该位均设置为0



## 3.9 TYPE描述符子类型

TYPE字段共4位，用于指示描述符的子类型，对于数据段和代码段，他们表示的类型不同，如下图所示，

| X    | E    | W    | A    | 描述符类别 | 含义             |
| ---- | ---- | ---- | ---- | ---------- | ---------------- |
| 0    | 0    | 0    | X    | 数据段     | 只读             |
| 0    | 0    | 1    | X    | 数据段     | 读、写           |
| 0    | 1    | 0    | X    | 数据段     | 只读，向下扩展   |
| 0    | 1    | 1    | X    | 数据段     | 读、写，向下扩展 |

| X    | C    | R    | A    | 描述符类别 | 含义                   |
| ---- | ---- | ---- | ---- | ---------- | ---------------------- |
| 1    | 0    | 0    | X    | 代码段     | 只执行                 |
| 1    | 0    | 1    | X    | 代码段     | 执行、读               |
| 1    | 1    | 0    | X    | 代码段     | 只执行、依从的代码段   |
| 1    | 1    | 1    | X    | 代码段     | 执行、读、依从的代码段 |

### 3.9.1 X（eXecutable）执行位

① X位表示是否可执行

② 数据段总是不可执行的，X = 0；代码段总是可执行的，X = 1



### 3.9.2 E（Expand）扩展位

① 用于不可执行段，E位指示段的扩展方向

② E = 0，向上（高地址方向）扩展；E = 1，向下（低地址方向）扩展



### 3.9.3 W（Writable）可写位

① 用于不可执行段，W位指示段是否可写（不可执行段总是可读的）

② W = 0，不允许写入，如写入将触发异常；W = 1，允许写入



### 3.9.4 C（Conforming）依从位

① 用于可执行段，C位指示段是否是特权级依从的

② C = 0，表示非依从代码段，这样的代码段可以从与他特权级相同的代码段调用，或者通过门调用

C = 1，表示依从代码段，这样的代码段允许从低特权级的程序转移到该段执行



### 3.9.5 R（Readable）可读位

① 用于可执行段，R位指示代码段是否允许读出（为了防止程序被破坏，代码段总是不可写入的）

② R = 0，不允许读出，如读出将触发异常；R = 1，允许读出



说明：R标志不是用于限制处理器读取指令的行为，而是用来限制程序像访问数据段一样访问代码段的内容。一个典型的例子，是只用mov指令和"CS:"段超越前缀读取代码段中的内容



### 3.9.6 A（Accessed）已访问位

① A位表示该描述符描述的段，最近是被否访问过

② 在创建描述符时，A位应该清零。之后每当该段被访问时，处理器自动将A位置1。对该位的清零由软件（操作系统）负责

③ 通过定期监视该位的状态，就可以统计出该段的使用频率。当内存紧张时，可以把不常用的段交换到硬盘上，从而实现虚拟内存管理



## 3.10 AVL（Available）位

① AVL位是软件可以使用的位，通常由操作系统使用，处理器并不使用该位







# 4. 特权级的三个维度

前面介绍了许多用于实现特权级保护的机制，现在终于可以开始说明80386究竟是如何利用这些机制来完成特权级保护的

特权级保护从本质上来说，是保护高特权级的内存、外设等资源不会被没有权限(低权限)的程序访问。主体结构是程序访问资源，而CPU需要在这个过程中进行特权级的校验

这里引入三种不同概念的特权级：**当前特权级CPL、描述符特权级DPL、请求特权级**

## CPL 当前特权级

current privilege level，当前特权级，表示当前所运行程序的特权级，更进一步的说，也就是当前CS代码段寄存器中所装载段选择子的后两位所决定的特权级





















































