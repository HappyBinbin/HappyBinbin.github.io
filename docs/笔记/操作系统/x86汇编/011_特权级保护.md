# 特权级保护

80386CPU为了给操作系统提供硬件级的可靠保护，提供了特权级保护功能。80386处于保护模式时，会改变CPU的行为方式，其中便包括开启特权级保护。实现良好的特权级保护是需要软硬件相协调的，CPU提供硬件机制的同时也需要与操作系统相配合，共同实现完善的特权级保护功能

# 1. 全局描述符表GDT

## 1.1 段描述符与描述符表

在8086中，为了让程序能在内存中浮动地加载装配，通过段地址和段内偏移地址共同组成最终的物理地址

在保护模式中，段机制依然存在，为了支持特权机保护，在一个段能够被访问之前，需要先进行“登记注册”

用于登记注册的一个段详细信息的数据结构被称为**段描述符**，固定为8个字节，64位，在一个多任务系统中会定义很多不同的段，一个段就对应着一个段描述符，为了统一的进行管理，需要在内存中开辟一段连续的空间集中紧密相连的描述符，而这一段连续的内存空间被称为描述符表（除了段描述符，还有门描述符，默认描述符等）

描述符表有多种类型，如：全局描述符表 GDT、局部描述符表 LDT，中断描述符表 IDT 等



## 1.2 全局描述符表的定义

全局描述符表（Global Descriptor Table，GDT）是最主要的描述符表，在进入保护模式之前，必须定义全局描述符表

理论上，GDT可以位于内存中的任何地方，但是初始设置的GDT一般位于1MB以下的内存范围内，这是因为设置初始GDT是在进入保护模式之前，而在进入保护模式之前，处理器只能访问1MB以下的内存空间

- 说明1：允许在进入保护模式之后，重新定义GDT

- 说明2：GDT表不是由用户程序自己建立的，而是在加载用户程序时，由操作系统根据用户程序的结构建立的，而用户程序通常无法建立和修改GDT，处理器借此实现保护功能




## 1.3 全局描述符表寄存器GDTR

![img](https://img-blog.csdnimg.cn/20210609144851944.png)



### 1.3.1 GDTR用途

为了跟踪GDT，处理器内部设置了一个48位的GDTR寄存器，同时提供了lgdt指令用于将GDT信息加载到GDTR中

GDT与GDTR的关系如下图所示，

![image-20220402113612274](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021136359.png)



### 1.3.2 GDTR构成

#### 32位GDT线性基地址

对于32位的处理器，GDTR中32位的线性基地址确保可以将GDT部署在4GB范围内的任何位置

#### 16位边界值

GDT边界值 = 表内最后一个字节相对于表开始处的偏移量，在数值上为表的总字节数减1

16位的边界值最大为65535，因此表的总字节数为65536。又因为每个段描述符需要8B，因此GDT表中最多可以定义（65536 / 8 = 8192）个描述符

说明：预留一个伏笔，由于GDT表中最多可以有8192个描述符，那么索引这些描述符就需要至少13位（详见段选择符的构成）

![image-20220402113629165](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021136230.png)

### 1.3.3 lgdt指令

lgdt指令用于将GDT表的基地址和界限值加载到GDTR中，指令格式如下，	

```assembly
lgdt m48
```

这里m48表示该指令的操作数是一个48位的内存区域，且要求低16位为GDT界限值，高32位是GDT线性基地址

![image-20220402113030497](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021130150.png)



- 说明1：lgdt指令在实模式和保护模式下均可执行

- 说明2：对于m48这个内存地址的有效地址（EA）的给出方式，在16位实模式下，EA是16位的；在32位保护模式下，EA是32位的

- 说明3：lgdt指令不影响任何标志位



# 2. 局部描述符表 LDT

现代的操作系统是多任务的，那么什么是任务呢？

**程序是保存在存储介质中的指令和数据的结合体，而正在执行程序的一个副本就是任务。**一个程序可以有运行在内存中的多个副本，每个副本都是一个任务。支持多任务的操作系统要让并发的多个任务和谐共处，就需要在任务之间通过一些手段令不同任务间彼此隔离。一般情况下，不同任务之间的内存是不互通的，每个任务都有自己的内存空间，一个任务不能随意访问另一个任务独有的内存空间

80386CPU的设计者建议为每个任务分配独有的描述符表，**这一描述符表被称为局部描述符表LDT。**每个任务私有的内存段，其段描述符不放在GDT中，而是放在LDT中

CPU通过可以通过GDTR寄存器来找到GDT所在的位置。同样的，80386提供了局部描述符表寄存器(**Local Descripter Table Register LDTR**)来追踪LDT的位置

和GDT不同的是，每个任务都有着自己的LDT。在多任务轮流执行的多任务系统中，正在执行的任务被成为当前任务，而LDTR则指向当前任务的LDT。任务切换时，LDTR中的数据会发生变化，指向新的当前任务



# 3. 存储器段描述符详解

![image-20211115192751797](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/image-20211115192751797.png)



存储器段描述符格式如上图所示，下面逐一说明其中的字段

描述符不是用户自己建立的，而是用户程序被操作系统加载时，有操作系统根据用户程序的结构而建立的。用户程序是无法自己修改和建立GDT的

用户程序只能老老实实的在自己的地盘上工作。这个时候操作系统为用户程序建立了几个段（定义了几个段描述符），用户程序就只能在这些段内工作，超出这个范围，或者未按预定的方法访问这些段，都将被处理器阻止



## 3.1 段基地址

① 段基地址为32位，确保段基址可以是0 ~ 4GB范围内的任意地址

② 32位段基地址分段保存，是源于80286处理器的历史遗留问题

说明：虽然段基地址可以是0 ~ 4GB范围内的任意地址，而且Intel处理器也允许地址不对齐访问。但是还是建议选取16B对齐的地址作为段基址，因为对齐可以使程序在访问代码和数据时的性能最大化



## 3.2 段界限

① 20位的段界限用来限制段的扩展范围，越过段界限的访问将被处理器阻止并触发异常

② 对于向上扩展的段，偏移量从0开始递增，段界限决定了偏移量的最大值（包含该值）

![image-20220402113832291](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021138374.png)



由于偏移量从0开始，所以（段界限 + 1）就是段的大小。因此，如果指定的段界为0，则段的大小为1

③ 对于向下扩展的段，段界限决定了偏移量的最小值（不包含该值）。段界限是偏移量所不允许的最小值，小于或等于就会触发异常。

![image-20220402113837727](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021138775.png)



段的大小为0xFFFF或0xFFFFFFFF到设置的段界限处，这里之所以分为16位和32位的偏移量最大值，是因为偏移量可能是16位寄存器提供的（e.g. 使用SP指针），也可能是32位寄存器提供的（e.g. 使用ESP寄存器）

如果指定的段界限为0，此时段的大小是最大的

- 说明1：向下扩展的段不一定用作栈段，但是通常用作栈段

- 说明2：使用向下扩展的段作为栈段的缺点


向下扩展的段的段内偏移量最大值一定是0xFFFF或0xFFFFFFFF，而SP或ESP寄存器一般并不设置为该值。但是即使不使用0xFFFF（FFFF）到SP（ESP）之间的范围，这段内存也包含在当前段中

![image-20220402113846939](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021138996.png)





## 3.3 G位粒度（Granularity）位

① 粒度用于解释段界限的单位

② 当G = 0，段界限以字节为单位；当G = 1，段界限以4KB为单位



## 3.4 S位类型位

① S位用于指定描述符的类型（Descriptor Type）

② 当S = 0，表示是一个系统描述符，且TYPE字段用来指定系统段的类型或门的类型

③ 当S = 1，表示是一个存储器的段描述符，且TYPE字段用来区分代码段和数据段（栈段也是特殊的数据段）

说明1：描述符的分类

![image-20220402114047685](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021140770.png)



其中系统描述符有如下类型

![image-20220402114059488](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021140561.png)





说明2：处理器对描述符的处理过程

处理器拿到描述符后，先根据S位判断其分类，然后根据TYPE字段得到子类型，之后解析描述符的其他字段



## 3.5 DPL描述符特权级

DPL字段(Descriptor Privilege Level)代表当前段描述符的特权级,占两bit位。

　　80386共支持4种特权级级别，分别是0,1,2,3。数字越小，特权级越高，0代表最高特权级，3代表最低特权级



① DPL表示描述符的特权级（Descriptor Privilege Level），指定要访问该段所必须具有的最低特权级

② 处理器共有4种特权级别，分别为0（最高特权级别）、1、2、3（最低特权级别）。刚进入保护模式时执行的代码具有最高特权级，可以看成是从处理器那里继承来的

③ 基于特权级的保护体现在如下2个方面

a. 不同特权级别的程序是相互隔离的，其互访是严格限制的

b. 有些处理器指令（特权指令）只能由0特权级的程序来执行



说明：为何CS寄存器的上电初始值为0xF000 ?

8086处理器[CS : IP]寄存器的初始值为[0xFFFF : 0x0000]，但是后续的X86处理器将上电初始值修改为[0xF000 : 0xFFF0]

修改前后，处理器上电后访问的第1条指令的地址是相同的，该修改就是为了兼容后续X86处理器引入的特权级模式

修改之后的CS寄存器初值为0xF000，当进入保护模式时，CS将被作为段选择器，其中的最低2位作为CPL，此时CPL = 0，为最高特权级，可以跳转到0特权级的操作系统代码中运行

如果不修改，当进入保护模式时，CPL = 3，为最低特权级，将无法跳转到0特权级的操作系统代码中运行



## 3.6 P位存在（Present）位

① P位用于指示描述符对应的段是否在内存中



② P位为0的2种情况，

a. 当内存紧张时，可能创建了段描述符，但是尚未准备对应的内存空间

b. 当内存紧张时，将不常使用的段交换到硬盘上，此时需要将P位置为0



③ P位由处理器负责检查，每当通过描述符访问内存中的段时，如果P位为0，处理器会差生一个异常中断。该中断对应的中断处理程序通常由操作系统提供，用于将该段从硬盘换回内存，并将P位置为1



说明1：这里描述的是以段为交换单位的虚拟内存管理机制，由于以段为单位进行交换性能消耗较大且容易导致内存碎片，后续被以页为单位的交换机制替代



说明2：一个段是否常用的标准，就需要依靠段描述符中TYPE字段中的A位（详见下文）



## 3.7 D/B位操作数大小位

① D/B位有3种功能，

a. 默认的操作数大小（Default Operation Size）标志

b. 默认的栈指针大小（Default Stack Pointer Size）标志

c. 栈上部边界（Upper Bound）标志



② D/B位的设立，主要是为了能够在32位处理器上兼容运行16位保护模式的程序（这种程序已经非常罕见，我们不做讨论）



③ 该标志对不同的段有不同的效果

a. 对于代码段，此位称作D位，用于指示指令中默认的偏移地址和操作数尺寸，其中D = 0表示默认16位；D = 1表示默认32位

e.g. 如果代码段的D位为0，处理器在该段上执行时，将使用IP寄存器，而不是EIP寄存器



b. 对于栈段，此位称作B位，用于在进行隐式的栈操作时，是使用SP寄存器还是ESP寄存器

同时，B位也决定了栈的上部边界，如果B = 0，那么栈段的上部边界为0xFFFF；如果B = 1，那么栈段的上部边界为0xFFFFFFFF



说明1：此处的栈段，更准确的说是向下扩展的数据段

说明2：在本课程中，D/B位均设置为1，不讨论16位保护模式的情况



## 3.8 L位64位代码段标志位

① L（Long mode, 64-bit Code Segment）位是64位代码段标志，保留此位给64位处理器使用

② 本课程中，讨论32位保护模式，该位均设置为0



## 3.9 TYPE描述符子类型

TYPE字段共4位，用于指示描述符的子类型，对于数据段和代码段，他们表示的类型不同，如下图所示，

| X    | E    | W    | A    | 描述符类别 | 含义             |
| ---- | ---- | ---- | ---- | ---------- | ---------------- |
| 0    | 0    | 0    | X    | 数据段     | 只读             |
| 0    | 0    | 1    | X    | 数据段     | 读、写           |
| 0    | 1    | 0    | X    | 数据段     | 只读，向下扩展   |
| 0    | 1    | 1    | X    | 数据段     | 读、写，向下扩展 |

| X    | C    | R    | A    | 描述符类别 | 含义                   |
| ---- | ---- | ---- | ---- | ---------- | ---------------------- |
| 1    | 0    | 0    | X    | 代码段     | 只执行                 |
| 1    | 0    | 1    | X    | 代码段     | 执行、读               |
| 1    | 1    | 0    | X    | 代码段     | 只执行、依从的代码段   |
| 1    | 1    | 1    | X    | 代码段     | 执行、读、依从的代码段 |

### 3.9.1 X（eXecutable）执行位

① X位表示是否可执行

② 数据段总是不可执行的，X = 0；代码段总是可执行的，X = 1



### 3.9.2 E（Expand）扩展位

① 用于不可执行段，E位指示段的扩展方向

② E = 0，向上（高地址方向）扩展；E = 1，向下（低地址方向）扩展



### 3.9.3 W（Writable）可写位

① 用于不可执行段，W位指示段是否可写（不可执行段总是可读的）

② W = 0，不允许写入，如写入将触发异常；W = 1，允许写入



### 3.9.4 C（Conforming）依从位

① 用于可执行段，C位指示段是否是特权级依从的

② C = 0，表示非依从代码段，这样的代码段可以从与他特权级相同的代码段调用，或者通过门调用

C = 1，表示依从代码段，这样的代码段允许从低特权级的程序转移到该段执行



### 3.9.5 R（Readable）可读位

① 用于可执行段，R位指示代码段是否允许读出（为了防止程序被破坏，代码段总是不可写入的）

② R = 0，不允许读出，如读出将触发异常；R = 1，允许读出



说明：R标志不是用于限制处理器读取指令的行为，而是用来限制程序像访问数据段一样访问代码段的内容。一个典型的例子，是只用mov指令和"CS:"段超越前缀读取代码段中的内容



### 3.9.6 A（Accessed）已访问位

① A位表示该描述符描述的段，最近是被否访问过

② 在创建描述符时，A位应该清零。之后每当该段被访问时，处理器自动将A位置1。对该位的清零由软件（操作系统）负责

③ 通过定期监视该位的状态，就可以统计出该段的使用频率。当内存紧张时，可以把不常用的段交换到硬盘上，从而实现虚拟内存管理



## 3.10 AVL（Available）位

① AVL位是软件可以使用的位，通常由操作系统使用，处理器并不使用该位



# 4 保护模式下的内存访问

## 4.1 段选择器与描述符高速缓存器

![image-20220402121614143](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021216207.png)



在32位保护模式下，段寄存器被扩充为两个部分

- 段选择器：在16位实模式下，使用方式与8086相同，用于存放逻辑段基址；在32位保护模式下，用于存放段选择符

- 描述符高速缓存器：这是一个程序不可见的部分，用来存放被选择段的线性基地址、段界限和段属性，该部分由处理器内部使用



**说明1：为什么需要描述符高速缓存器 ?**

因为GDT表在内存中，如果每次内存访问都要先根据段选择符访问GDT表，再根据其中的段线性基地址计算线性地址并访问内存，效率将非常低

因此在处理器的寄存器层面进行缓存，在用段选择符设置段选择器之后，处理器将会访问GDT表并缓存该表项。后续只要段选择器中的内容不变，访问内存时就直接使用描述符高速缓存器中的内容



**说明2：32处理器在16位实模式下也使用了高速缓存器**

当32位处理器运行在16位实模式下时，如果设置了段寄存器，处理器会将逻辑段基址左移4位，并传送到描述符高速缓存器。此后就一直使用描述符高速缓存器中的段线性基地址

需要注意的是，在16位实模式下，段描述符高速缓存器中的线性基地址只有低20位有效，高12位全部为0

我们在Bochs虚拟机中执行如下指令，并查看段寄存器的状态

![image-20220402122134820](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021221868.png)

![image-20220402122120360](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021221469.png)



**说明3：32处理器在16位实模式下段长度依然只有64KB**

当32位处理器运行在16位实模式下时，也可以使用32位寄存器进行寻址，但是这并不会使得段长度达到4GB

这是因为在实模式下（参考上一张截图），段界限被设置为0x0000FFFF，粒度G位被设置为0，因此段长度为64KB，超出该范围的访问会触发处理器异常

我们在实模式下运行如下代码进行验证，可见ebx提供的有效地址已经超过64KB，应该触发处理器异常

![image-20220402122649190](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021226242.png)



经过验证，越界访问确实触发了处理器异常，且异常原因为读取越界

![image-20220402122654626](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204021226677.png)





## 4.2 段选择符（Segment Selector）

保护模式下段寄存器中装载的不再是段基址，而是段选择子。但CPU从本质上来说依然是通过段基址+偏移地址进行内存寻址的，只不过在中间引入了一层段选择子的抽象，用于实现特权级保护

![img](https://img-blog.csdnimg.cn/20210609145409267.png)

段选择符由3部分构成

**描述符索引**

- 共13位，正好最多可以索引8192个描述符，与GDT表的最大表项数匹配，用于在段描述符表中定位对应的段描述符

**描述符表指示器TI（Table Indicator）**

- TI = 0，表示描述符在GDT中；TI = 1，表示描述符在LDT中

根据TI的不同，在加载段选择子时，CPU将会去访问对应的段描述符表，根据描述符索引获取对应的段描述符信息，加载到段寄存器中，由于段选择子中并没有段基址、段界限等内存寻址时的关键数据，这些数据都只在段选择子指向的段描述符中。但每次使用段寄存器寻址时，不能总是通过段描述符表获取段描述符数据，频繁的内存寻址效率太低

因此，80386的设计者在段寄存器中设置了描述符高速缓冲器。只有当段选择子变化时，段寄存器才需要访问一次描述符表，获取对应的段描述符数据，将其存入描述符高速缓冲器中。之后，对于当前同一段选择子的访问，便可以直接从描述符高速缓冲器中获取数据，极大的提高了CPU通过段寄存器进行内存寻址的性能



## 4.3 保护模式访问内存过程

![image-20211115193219154](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/image-20211115193219154.png)



① 当处理器执行任何改变段选择器的指令时，就将指令中提供的索引号乘以8作为偏移地址，同GDTR中提供的线性基地址相加，以访问GDT

② 如果权限检查通过，则将描述符加载到描述符高速缓存。之后只要不改变段选择器，就直接用描述符高速缓存中的线性基地址

<img src="https://happychan.oss-cn-shenzhen.aliyuncs.com/img/image-20211115193242985.png" alt="image-20211115193242985" style="zoom:80%;" />

③ 访问内存时，将描述符高速缓存中的线性基地址与寻址方式给出的段内偏移相加，构成要访问的线性地址

④ 对该线性地址的访问请求进行检查（e.g. 是否越界，是否可读写），如果检查通过，则进行内存访问



访问代码段也是与上述过程类似：

只不过指令的偏移地址一般是由EIP寄存器指定。那么访问一个内存中的指令大概就是下面的过程：

![image-20220403172219453](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204031722532.png)



# 5. 特权级的三个维度

前面介绍了许多用于实现特权级保护的机制，现在终于可以开始说明80386究竟是如何利用这些机制来完成特权级保护的

特权级保护从本质上来说，是保护高特权级的内存、外设等资源不会被没有权限(低权限)的程序访问。主体结构是程序访问资源，而CPU需要在这个过程中进行特权级的校验

这里引入三种不同概念的特权级：**当前特权级CPL、描述符特权级DPL、请求特权级**

## 5.1 CPL 当前特权级

current privilege level，当前特权级，表示当前所运行程序的特权级，更进一步的说，也就是当前CS代码段寄存器中所装载段选择子的后两位所决定的特权级

BIOS 在加载操作系统并进入保护模式时，处理器会在执行第一条指令时自动的将 CPL 设置为 0，可以看做操作系统在进入保护模式时拥有的最高 CPL 时从处理器继承而来。之后便由操作系统程序负责整个计算机系统的管理。例如加载用户应用程序时，将用户程序的 CPL 设置为最低特权级 3，应用程序虽然不希望自己被放在最低特权级，但操作系统主导了应用程序的加载，其所使用的段描述符、LDT 等都由操作系统管理和创建，应用程序只能专注于自己的业务功能，无权控制自己的 CPL 当前特权级

特权级分为 4 种，可以被看做几个不同大小的同心圆，像一个个指环，特权级 0 也被称为 ring0，因此运行在核心处 ring0 特权级的操作系统程序，也被称为内核程序

<img src="https://happychan.oss-cn-shenzhen.aliyuncs.com/img/pic/202204031416758.png" alt="image-20220403141647597" style="zoom: 80%;" />

**特权指令**

在整个80386的指令集中，其中很多底层的、权限很大的指令被规定只能被最高权限的程序(例如操作系统)执行

**处于最高当前特权级CPL=0的程序才有权限执行的指令，叫做特权指令**

其中主要包括停机指令；加载GDT、LDT的指令；读写控制寄存器的mov指令等等



## 5.2 DPL 描述符特权级

Descriptor Privilege Level，目标特权级，用于标识所指向目标的特权级，每个段描述符都有DPL字段属性

**DPL特权级的高低，决定了能够被位于何种特权级的程序所访问**

CPU 对内存段访问的特权级保护是在段选择子加载的时候进行的，当有新的段选择子准备加载到段寄存器时，CPU会根据段寄存器的类型进行相应的校验

### 代码段访问的保护机制

对于代码段寄存器来说，加载新的段选择子可能意味着 CPL 的变化，校验比较严格，**段间控制转移一般只允许发生在相同特权级的程序之间。**也就是说，一个当前特权级 CPL 为2程序，只能跳转到另一个特权级 DPL 同样为2的代码段执行，而无法跳转到特权级DPL为0、1、3的代码段

一般程序内部相同特权级代码段间互相跳转都是没问题的，但还存在一些场景需要允许低特权级的程序去调用高特权级的代码，例如低 CPL 的应用程序去调用高 DPL 的系统调用例程

有两个方法可以允许低CPL的程序跳转高DPL的代码段：

1. 将高特权级的目标代码段定义为依从的，也就是将代码段描述符中TYPE字段的C位设置为1，代表当前代码段是**特权级依从的**。当低特权级的程序跳转至高特权级的代码段时，CS的后两位不发生变化，CPL和调用程序保持一致
2. 通过门来进行，门(Gate)也是一种描述符，被称为门描述符。门描述符区别于段描述符，段描述符描述的是一个段，而门描述符描述的是一段可执行的代码、一个程序或者一个任务，系统调用通常使用门描述符来实现。使用 **jmp far**指令可以将控制通过门调用转移到高特权级代码段，但是依然不改变当前特权级 CPL；使用**call far **指令则在将控制转移到高特权级代码段的同时，还会将当前特权级CPL提升到和目标代码段 DPL 一致，也就是说，一个 CPL 为3的应用程序，通过门调用调用到了一个 DPL=0 的代码段程序，则CPU将会将当前特权级 CPL 提升为0，和目标代码段特权级保持一致

### 数据段访问的保护机制

数据段访问的保护机制相对来说简单一些：**处于低 CPL 的程序无法访问高DPL的数据段。**换句话说，在访问数据段前，向数据段寄存器(**DS/ES/FS/GS**)载入新的段选择子时，要求当前CPL必须高于或等于目标段DPL(**数值上CPL <= DPL**

特别的，为了避免高特权级的程序由于栈空间不足而崩溃以及阻止不同特权级间栈数据的交叉引用，处理器在特权级变化的时候，堆栈也会跟着发生变化。所以，**向栈段寄存器SS载入新的段选择子时，要求当前CPL必须完全等于目标的DPL(在数值上CPL = DPL)**



## 5.3 RPL请求特权级

Request Privilege Level，请求特权级，代表请求者的特权级

在执行段间控制跳转指令时，需要提供目标代码段的选择子，载入CS代码段寄存器；在访问数据段时，也需要将数据段选择子装载入DS、ES等数据段寄存器中。无论是执行控制转移，还是访问数据段，都可以看作是当前执行任务的一个请求，RPL也就是当前请求者的特权级

大多数情况下，请求者就是当前任务，因此 CPL=RPL，谁负责提供段选择子，谁就是请求者。但在某些时刻，提供段选择子的请求者和当前任务并不相同

### 例子：

我们知道使用call far转移指令调用操作系统提供的调用门执行系统调用时，会将CPL从应用程序的ring3提高到操作系统所处的ring0，假如操作系统提供了一个系统调用，用于从磁盘中读取数据，并将其写入到应用程序数据段的指定位置中(**由于系统调用中可能会执行一些特权指令，或是外设被限制了访问特权级，所以通过调用门call far时会提升CPL**)。这个系统调用有三个参数：磁盘的扇区号(指定从磁盘的什么位置读取)，需要写入的数据段的段选择子(指定写入哪一数据段)，最后一个是数据段的段内偏移地址(用于更精确的控制写入数据的段内位置)

**这个系统调用的设计看起来还不错，能读取指定磁盘扇区的数据并写入指定数据段中，但却隐藏了一个严重问题**，如果应用程序的编写者是一名恶意的攻击者，他给出的数据段选择子参数指向的不是应用程序自己的数据段，而是操作系统的数据段选择子。虽然只有CPL=0的程序才有权限访问操作系统设置的DPL=0的内核数据段，但是由于通过call far调用门进行系统调用时，会将CPL提升为0，因此这个操作会被允许执行。这是一个很严重的漏洞，**通过call far调用门实现的系统调用，模糊了CPL和事实上的请求者特权级的关系**，使得只有CPL、DPL的校验机制在这种情况下显得无能为力。CPU很难区分出在段选择子的加载时，这个段选择子究竟是操作系统提供的还是恶意应用程序提供的

因此，80386的设计者在CPL、DPL的基础上又提供了RPL请求特权级来解决这个问题。虽然CPU不知道段选择子的提供者是谁，但操作系统是知道的。操作系统在内核中访问内存段时，请求者自然是操作系统自己；而操作系统提供系统调用为应用程序服务时，也能明确知道请求者是低特权级的应用程序

在上述磁盘读取系统调用的例子中，**操作系统可以在系统调用的程序中修改应用程序提供的段选择子的RPL，将其设置为和应用程序匹配的低特权级后再送入段寄存器中。CPU在校验时，除了要求CPL高于或等于目标段的DPL(数值上CPL <= 目标DPL)，也要求给出的段选择子中的RPL也必须高于或等于目标段的DPL(数值上RPL <= 目标DPL)**

引入了RPL后，并且操作系统在系统调用中合理的设置了段选择子的RPL，上述漏洞就不复存在了。正常的应用程序能够访问磁盘数据，并正确的写入自己的数据段中(CPL=0 RPL=3，目标DPL=3 校验通过)；但恶意的应用程序即使传入的段选择子RPL=0，也会被系统调用给重置为RPL=3，非法访问操作系统内核数据段的企图将会被CPU发现，引发异常中断(CPL=0 RPL=3，DPL=0 校验不通过)



## 5.4 特权级保护校验规则

### 代码段特权级校验规则

**非特权级依从代码段直接转移：** 直接控制转移到**非特权级依从**的代码段时，要求当前特权级CPL、请求特权级RPL都等于目标代码段DPL(**数值上CPL = 目标代码段DPL，RPL = 目标代码段DPL**)

**特权级依从代码段直接转移：**直接控制转移到**特权级依从**的代码段时，要求当前特权级CPL、请求特权级RPL都低于或等于目标代码段DPL(**数值上CPL >= 目标代码段DPL，RPL >= 目标代码段DPL**)

**门描述符特权转移：**通过门描述符进行的控制转移规则较为复杂，在后续关于门描述符的博客再对门描述符控制转移的规则再进行展开介绍

### 数据段特权级校验规

CPU允许高当前特权级的程序访问低特权级别的数据段。换句话说，低当前特权级的程序无法访问高特权级的数据段

即要求当前特权级CPL，请求特权级RPL都必须高于或等于目标数据段DPL(**数值上CPL <= 目标数据段DPL，RPL <= 目标数据段DPL)**

### 栈段特权级校验规则

CPU要求任何时候，访问的栈段特权级必须和当前特权级CPL相一致

即要求当前特权级CPL，请求特权级RPL都必须等于目标栈段DPL(**数值上CPL = 目标栈段DPL，RPL = 目标栈段DPL**)



## 5.5 IO 特权级保护
