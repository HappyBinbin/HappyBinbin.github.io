# 学习目标

- 认识内存中的栈结构
- 学习使用栈完成显示数字

## 前置知识

栈是一种特殊的结构，push 入栈，pop 出栈，只有栈顶指针指向的元素才可以被访问

8086汇编提供了对应的指令PUSH和POP来对内存进行入栈、出栈操作。同时8086CPU是16位的，因此POP和PUSH所操作的栈中元素大小为两个字节

**相关指令**

- PUSH [寄存器]，将指定寄存器中的值传送到栈顶指针处，栈顶指针上移
- PUSH [内存单元]，将指定内存单元处的值传送到栈顶指针处，栈顶指针上移
- POP [寄存器]，将栈顶指针处的内存数据传送到指定寄存器中，栈顶指针下移
- POP [内存单元]，将栈顶指针处的内存数据传送到指定内存单元处，栈顶指针下移

**栈顶指针**

Q：CPU该如何知道在栈操作指令中没有明确声明的栈顶指针呢？

A：CPU通过另外两个寄存器SS(stack-segment 栈段寄存器)和SP(stack-point 堆栈指针寄存器)来确定栈顶指针

**规定**

- SS标识栈内存段，而SP标识内存段中栈顶指针的内存地址
- 8086的一段连续栈内存地址中，将高位内存视为栈底，低位视为栈顶

**出入栈**

- push ，SS不变，SP自减2（空出两个字节共16位的内存空间），标识心的栈顶，然后将数据送入栈顶
- 先将栈顶元素送入目的地(寄存器/内存)，随后SS不变而将SP自增2(缩小栈)，标识新的栈顶

**栈的越界问题**

Q：如果不断的出栈导致sp指针越过栈的底部会怎样？不断的入栈导致SP越过了栈的顶部又会发生什么呢？

A：栈访问越界问题必须由程序员自己避免。在出栈入栈过程中，栈段寄存器SS是不变的，这意味着8086能直接支持的最大栈就是64KB(段的最大值)，而SP在极端情况下会发生栈的上溢或者下溢；或者一个物理段被分成了许多的逻辑段，对栈顶指针的控制出现失误，会导致不同逻辑段间的数据被覆盖

## 代码

```assembly
         ;代码清单7-1
         ;文件名：c07_mbr.asm
         ;文件说明：硬盘主引导扇区代码
         ;
         
         jmp near start
	
 message db '1+2+3+...+100='
        
 start:
         mov ax,0x7c0           ;设置数据段的段基地址 
         mov ds,ax

         mov ax,0xb800          ;设置附加段基址到显示缓冲区
         mov es,ax

         ;以下显示字符串 
         mov si,message          
         mov di,0
         mov cx,start-message
     @g:
         mov al,[si]
         mov [es:di],al
         inc di
         mov byte [es:di],0x07
         inc di
         inc si
         loop @g

         ;以下计算1到100的和 
         xor ax,ax
         mov cx,1
     @f:
         add ax,cx
         inc cx
         cmp cx,100
         jle @f

         ;以下计算累加和的每个数位 
         xor cx,cx              ;设置堆栈段的段基地址
         mov ss,cx
         mov sp,cx

         mov bx,10
         xor cx,cx		 ;记录往栈里放了多少个数，进栈与出栈个数要一致
     @d:
         inc cx
         xor dx,dx
         div bx
         or dl,0x30     ;实际上应该是add指令，但是这可以是or指令，因为dl高四位为0,0x30低四位位0
         push dx
         cmp ax,0
         jne @d

         ;以下显示各个数位 
     @a:
         pop dx
         mov [es:di],dl
         inc di
         mov byte [es:di],0x07              ;显示字符的颜色属性
         inc di
         loop @a
       
         jmp near $ 
       

times 510-($-$$) db 0
                 db 0x55,0xaa

```

## 代码解析

那么下面就开始分析：

- 8行：就是想要显示‘1+2+3+…+100’，只不过这里先要将它存储在这里，好方便下面的循环传送。message是标号，代表它当前位置的汇编地址

- 11-14行：设置数据段基地址与附加段基地址（也就是显存的基地址），这里前几篇文章已经讲了很多，不懂的可以回头看前面的文章。

- 18-28行：将字符串‘1+2+3+…+100’显示出来。这里同样使用了循环的方法将字符串循环传送到显存。CX这里代表计数器，表示要传送的字符串的字节数。inc指令代表加1的意思。

- 31-37行：计算1-100的和。这里将计算结果存到AX寄存器。CX每次加1是代表下一次要加的数。

- 40-53行：计算累加和的各个数位。毕竟我们要显示这个累加和嘛，又不能直接将它发送到显示缓冲区直接显示，直接将它的各个数位拆解出出来显示。这几行，是我们今天要重要研究的汇编代码。它涉及到一个新的概念----栈

得到了累加和之后，前两篇文章，是将各个数位保存在数据段中。现在我们将各个数位保存在一个叫做栈的地方。

栈----是一种特殊的数据存储结构，数据的存取只能从一端进行。这样先进去的数据只能最后出来。后进去的数据倒是最先出来。

如下图：

![image-20211103203450163](https://gitee.com/HappyBinbin/pcigo/raw/master/202111032034221.png)


和代码段，数据段和附加段一样，栈也是一种内存段，叫做栈段。由栈寄存器SS指向。

针对栈有两种操作方式：push和pop。这个应该大家都理解。压栈和出栈只能在一端进行。所以需要用栈指针寄存器SP来指示下一个数据应当压入到什么位置，或者数据从哪里弹出。

定义栈需要两个步骤。即指定SS和SP寄存器。为此40-42行，设置了SS和SP。他们都是指向0地址。

到目前为止，我们已经定义了3个段。如下图是我们当前程序的内存布局：


总内存容量是1MB，物理地址范围是0x00000-0xFFFFF

其中数据段长度是64KB（实际上它的长度无关紧要）占据的物理地址范围是0x07C00-0x17BFF，对应的逻辑地址为范围为 0x07C0:0x0000-0x7C00:0xFFFF;

代码段和栈段是同一个段，占据着物理地址0x00000-0x0FFFF，对应的逻辑地址的范围是0x0000:0x0000-0x0000:0xFFFF。

虽然代码段和栈段在本质上指向同一块内存区域，但是通过后面的学习我们会知道，他们互不干扰。

分解各个数位还是要靠除法来做，44行将除数10传送给寄存器BX。

由于每次分解得到的数位都是压栈的，所以后面再出栈的时候，我们需要记住总共有多少个。这里用CX寄存器记录个数。所以45行，先将CX寄存器清零。

源程序第47-53行也是一个循环体，没执行一次，分解出一个数位。每次分解时，CX加1，表明数位又多了一个，这是源程序47行所做的事。其他指令较为简单治理不再赘述。

- 57-62行：出栈，并显示各个数位。

这几行都比较简单。pop指令的意思是将逻辑地址SS:SP处的一个字弹出到寄存器DX中，然后将寄存器SP的内容加上操作数的字长（2）。

- 64行：为了让我们看到显示屏的显示效果，这里是一个死循环，防止程序退出。

- 67-68行：填充空的字节区间。然后最后的0x55和0xaa是主引导扇区的有效标志。

## 进一步认识栈

上述我们从代码层面第一次接触到栈这种结构。那么下面我们就来总结一下，做几点说明。

1. push指令的操作数可以是16位寄存器或者16位内存单元。push指令执行后，压入栈中的仅仅是该寄存器或者内存单元中的数值。
2. 栈在本质上也只是普通的内存区域，之所以用push和pop指令来访问，是因为你把它看成栈而已。引入栈和push、pop只是方便程序开发而已。
3. 要注意保持栈平衡。push多少，pop多少。
4. 在编写程序时，必须充分估计所需的栈空间，以防止破坏有用的数据。
5. 尽管不能完全阻止程序中的错误，但是，通过将栈定义到一个单独的64KB内存段，可以使错误仅局限于栈段，而不破坏其他段的有用数据。



























