# 抽象工厂模式

## Reference

[1] [bugstack.cn/md/develop/…](https://link.juejin.cn?target=https%3A%2F%2Fbugstack.cn%2Fmd%2Fdevelop%2Fdesign-pattern)

[2] [c.biancheng.net/view/1397.h…](https://link.juejin.cn?target=http%3A%2F%2Fc.biancheng.net%2Fview%2F1397.html)

[3] [refactoringguru.cn/design-patt…](https://link.juejin.cn?target=https%3A%2F%2Frefactoringguru.cn%2Fdesign-patterns%2Fvisitor%2Fjava%2Fexample)

[4] [cmsblogs.com/article/140…](https://link.juejin.cn?target=https%3A%2F%2Fcmsblogs.com%2Farticle%2F1407700262654709760)

[5] [blog.csdn.net/lovelion](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Flovelion)

## 工厂方法分析

还是上一篇的披萨项目背景，在这个背景下，虽然通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。

> Q：如何减少系统中类的个数？
>
> A：我们可以考虑**将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产**

## 产品等级结构与产品簇

在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法具有唯一性，一般情况下，一个具体工厂中只有一个或者一组重载的工厂方法。但是有时候我们希望一个工厂可以提供多个产品对象，而不是单一的产品对象，如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。为了更好地理解抽象工厂模式，我们先引入两个概念：

- **产品等级结构**：**产品等级结构即产品的继承结构**，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
- **产品族**：在抽象工厂模式中，**产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品**，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。

产品等级结构与产品族示意图如图所示：

![image-20220111113845209](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20220111113845209.png)

在图3中，不同颜色的多个正方形、圆形和椭圆形分别构成了三个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。图3中一共有五个产品族，分属于三个不同的产品等级结构。我们只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一确定这个产品。

当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。**抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。** 

抽象工厂模式与工厂方法模式**最大的区别在于**，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。     

**当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。** 抽象工厂模式示意图如图所示：

![image-20220111114113730](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20220111114113730.png)

每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中

## 抽象工厂概述

> 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。

在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族，抽象工厂模式结构如图所示：

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20220111114703656.png" alt="image-20220111114703656" style="zoom:80%;" />



在抽象工厂模式结构图中包含如下几个角色：

**● AbstractFactory（抽象工厂）：** 它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。

**● ConcreteFactory（具体工厂）：** 它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。

**● AbstractProduct（抽象产品）：** 它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。

**● ConcreteProduct（具体产品）：** 它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。

在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类，其典型代码如下所示：

```java
abstract class AbstractFactory {
    public abstract AbstractProductA createProductA(); //工厂方法一
    public abstract AbstractProductB createProductB(); //工厂方法二
    ……
}
```

具体工厂实现了抽象工厂，每一个具体的工厂方法可以返回一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下所示：

```java
class ConcreteFactory1 extends AbstractFactory {
    //工厂方法一
    public AbstractProductA createProductA() {
        return new ConcreteProductA1();
    }
    //工厂方法二
    public AbstractProductB createProductB() {
        return new ConcreteProductB1();
    }
    ……
}
```

## 利用抽象工厂进行改造

- 将 createPizza( ) 抽象到一个抽象工厂类中，让具体工厂去继承抽象工厂，实现对应方法。当然也可以将createPizza( ) 细化成多个，例如 createChessPizza( ), createPepperPizza( )，这样更加有利于理解，多个抽象方法即多种不同产品的等级结构，一个具体的工厂锁创建的产品对象构成一个产品族。
- 这里进行不同口味的判断代码，还是需要进行不断增加修改 if else 进行判断的，后期可以做成 Map<Enum, concrete Pizza> 来进行策略选择

![image-20220111115333907](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20220111115333907.png)



## 开闭原则的倾斜性

个人理解，这个披萨项目选择的是以地区作为维度来充当`产品簇`，而以不同口味的披萨来充当不同的`产品等级结构`，所以在阅读玩 [lovelion](https://blog.csdn.net/lovelion/article/details/9319571) 这篇文章后，我对这个例子进行一定的解读和仿造。（错误难免，还请麻烦各位读友斧正）

> 在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦。
>
> - 新增产品簇，如果新增一种四川口味的披萨，只需要新增一个具体四川工厂类，然后新增具体的产品类即可。
> - 假设要新增购买汉堡的功能，但是发现原有系统居然不能够在符合“开闭原则”的前提下增加新的组件，因是抽象工厂 Absfactory 中根本没有提供创建汉堡的方法，如果需要增加新增汉堡，首先需要修改抽象工厂接口 Absfactory ，在其中新增声明创建汉堡的方法，然后逐个修改具体工厂类，增加相应方法以实现在不同的地区中创建汉堡，此外还需要修改客户端，否则无法应用于现有系统。

怎么办？答案是抽象工厂模式无法解决该问题，这也是抽象工厂模式最大的缺点。

抽象工厂模式的这种性质称为“开闭原则”的倾斜性。“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的，对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：

- **增加产品族**：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。
- **增加新的产品等级结构**：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。

正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。

## 小结

主要优点：

- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
- 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”



主要缺点：

- 增加新的产品等级结构麻烦，违背开闭原则



适用场景：

- 一个系统不应该依赖于产品类的实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦
- 系统中有多于一个的产品簇，而每次只适用其中某一产品簇
- 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型
- 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构





