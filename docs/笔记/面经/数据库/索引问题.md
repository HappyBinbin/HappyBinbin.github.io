[TOC]

## 1.谈谈对索引的理解

索引是存储引擎用于提高数据查询效率的一种数据结构，索引类似于字典里的目录。

- hash索引：底层就是 hash 表。
- B树索引：B树是一种多路搜索树，n 路搜索树代表每个节点最多有 n 个子节点。每个节点存储 key + 指向下一层节点的指针+ 指向 key 数据记录的地址。查找时，从根结点向下进行查找，直到找到对应的key。
- B+树索引：B+树是b树的变种，主要区别在于：B+树的非叶子节点只存储 key + 指向下一层节点的指针，也就是只存索引，不存数据，数据都保存在叶子节点中。另外，B+树的叶子节点之间通过指针来连接，构成一个有序链表，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。

索引有三个优点： ①减少了服务器需要扫描的数据量；②帮助服务器避免排序；③将随机IO变为顺序IO，因为 B+ 树索引是有序的，它将相邻的数据都存储在一起。

索引的缺点：创建索引和维护索引会耗费时间；索引会占用物理空间；当对表进行增删改时，索引也需要动态维护，这样会降低数据的维护速度。一般在频繁使用或需要排序的字段上建立索引，而对于很少查询或重复值较多的列，不适合建立索引。

（InnoDB 中使用了 B+ 树索引，它先通过 B+ 树找到数据所在的页，然后将页读到内存，在内存中找到要查找的数据。Mysql 将索引存放在磁盘而不是内存中，减少了内存消耗）

## 2.B树和B+树的区别？为什么使用B+树？（B+树底层文件是怎么存储的）

1. 磁盘读写代价低。 B+树的中间节点存的是索引，不存储数据，数据都保存在叶子节点中，而B树的所有节点都能存放数据。所以B+树 磁盘读写的代价比B树低，因为中间节点不放数据，所以相同的磁盘块能存放更多的节点，一次性读入内存的节点数量也就越多，所以IO读写次数就降低了。
2. 查询效率稳定。 B+树的叶子节点位于同一层，数据也都位于叶子节点中，所以每次查找都是从根节点找到叶子节点，效率很稳定。而B树在查到关键字后就停止查找了，效率不够稳定。
3. 便于范围查找。 B+树的叶子节点还按照大小，通过链表有序的串联在一起，在进行遍历查询时，只需要遍历这个链表即可，而且还支持范围查询，查到范围的开始节点，然后往后遍历即可实现。而B树没有这样的链表，只能通过中序遍历来查找数据，不支持范围查询。

## 3. MySQL为什么要用B+树存储索引？而不用平衡二叉树（红黑树）、Hash索引(散列表)、B树、跳表？

1. Hash索引(散列表)：如果只查询单个值的话，hash 索引的效率非常高，时间复杂度为O(1)。但是 hash 索引有几个问题：1）不支持范围查询；2）不支持索引值的排序操作；3）不支持联合索引的最左匹配规则。
2. 平衡二叉树（红黑树）：查询性能也好，时间复杂度O(logn)，中序遍历可以得到一个从小到大有序的数据序列，但不支持区间查找。而且由于是二叉树，当数据量很大时树的层数就会很高，从树的根结点向下寻找的过程，每读1个节点，都相当于一次IO操作，因此他的I/O操作会比B+树多的多。
3. B树索引： 见上面B树和B+树的区别。
4. 跳表：是一种链表加多层索引的结构，时间复杂度O(logn)，支持区间查找，**而B+树是一种多叉树，可以让每个节点大小等于操作系统每次读取页的大小，从而使读取节点时只需要进行一次IO即可。**而且同数量级的数据，跳表索引的高度会比 B+ 树的高，导致 IO 读取次数多，影响查询性能。

## 4.B+树一个节点有多大？一千万条数据，B+树多高？

B+树一个节点的大小设为一页或页的倍数最为合适。因为如果一个节点的大小 < 1页，那么读取这个节点的时候其实读取的还是一页，这样就造成了资源的浪费。
在 MySQL 中 B+ 树的一个节点大小为“1页”，也就是16k。之所以设置为一页，是因为对于大部分业务，一页就足够了：
首先InnoDB的B+树中，非叶子节点存的是key + 指针；叶子节点存的是数据行。
对于叶子节点，如果一行数据大小为1k，那么一页就能存16条数据；对于非叶子节点，如果key使用的是bigint，则为8字节，指针在mysql中为6字节，一共是14字节，则16k能存放 16 * 1024 / 14 = 1170 个索引指针。于是可以算出，对于一颗高度为2的B+树，根节点存储索引指针节点，那么它有1170个叶子节点存储数据，每个叶子节点可以存储16条数据，一共 1170 x 16 = 18720 条数据。而对于高度为3的B+树，就可以存放 1170 x 1170 x 16 = 21902400 条数据（两千多万条数据），也就是对于两千多万条的数据，我们只需要高度为3的B+树就可以完成，通过主键查询只需要3次IO操作就能查到对应数据。所以在 InnoDB 中B+树高度一般为3层时，就能满足千万级的数据存储，所以一个节点为1页，也就是16k是比较合理的。

## 5.聚集索引 vs 非聚集索引

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121205923886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MxMXNob3dfMTYz,size_16,color_FFFFFF,t_70)


InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。

若对Name列进行条件搜索，则需要两个步骤：
第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。
第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）

MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

### 5.2 聚簇索引的优势

看上去非聚簇索引的效率明显要低于聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？非聚簇索引的优势在哪？

由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。

辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。

聚簇索引适合用在排序的场合，非聚簇索引不适合

取出一定范围数据的时候，使用用聚簇索引

二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据

可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

### 5.3 聚簇索引的劣势

维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片，使用独享表空间可以弱化碎片表。因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，


所以建议使用int的auto_increment作为主键


主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）

如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间

mysql中聚簇索引的设定
聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。

### 5.4 为什么建议使用主键自增的索引？

对于这棵主键索引的树：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210131210331521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MxMXNob3dfMTYz,size_16,color_FFFFFF,t_70)

主键索引
如果插入 ID = 650 的一行数据，那么直接在最右边插入就可以了

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210131210342247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3MxMXNob3dfMTYz,size_16,color_FFFFFF,t_70)


但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间。如果刚好 R4 所在的数据页已经满了，需要进行页分裂操作，这样会更加糟糕。

但是，如果主键是自增的，每次插入的 ID 都会比前面的大，那么每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。
