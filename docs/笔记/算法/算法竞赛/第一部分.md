## 算法tip

### 如何求一个整数的各个位的值？

- 百位等于n/100（注意这里取的是商的整数部分）
- 十位等于n/10%10（这里的%是取余数操作）
- 个位等于n%10
- 其他位数按照这个规则递推

### 如何不用中间值交换两个数的值？

> a = a + b;
> b = a - b;
> a = a - b;
>
> 执行完a=a+b后：a=a 0 +b 0 ，b=b 0 。
> 执行完b=a-b后：a=a 0 +b 0 ，b=a 0 。
> 执行完a=a-b后：a=b 0 ，b=a 0 。

### 误差避免

假设在经过大量计算后，由于误差的影响，整数1变成了0.9999999999，floor的结果会是 0 而不是1。为了减小误差的影响，一般改成四舍五入，即<font color='red'>floor(x＋0.5)</font>。如果难以理解，可以想象成在数轴上把一个单位区间往左移动0.5个单位的距离。floor（x）等于1的区间为[1，2），而floor（x＋0.5）等于1的区间为[0.5，1.5）

### 近似计算

![image-20210330163525783](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/20210330163525.png)

```c++
#include<stdio.h>
int main() {
    double sum = 0;
    for(int i = 0; ; i++) {
        double term = 1.0 / (i*2+1);
        if(i % 2 == 0) sum += term;
        else sum -= term;
        if(term < 1e-6) break;
    }
    printf("%.6f\n", sum);
    return 0;
}
```

### 阶乘之和

输入n，计算S＝1！＋2！＋3！＋…＋n！的末6位（不含前导0）。n≤10 6 ，n！表示前n个正整数之积。

样例输入： 10
样例输出： 37913

```c++
#include<stdio.h>
#include<time.h>
int main()
{
    const int MOD = 1000000;
    int n, S = 0;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        int factorial = 1;
        for(int j = 1; j <= i; j++)
            factorial = (factorial * j % MOD);
        S = (S + factorial) % MOD;
    }
    printf("%d\n", S);
    printf("Time used = %.2f\n", (double)clock() / CLOCKS_PER_SEC);
    return 0;
}
```

#### :star:补充知识

计算只包含加法、减法和乘法的整数表达式除以正整数n的余数，可以在
每步计算之后对n取余，结果不变。

![image-20210330163816253](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/20210330163816.png)

25！末尾有6个0，所以从第5项开始，后面的所有项都不会影响和的末6位数字——只需要在程序的最前面加一条语句“if（n＞25）n＝25；”，效率和溢出都将不存在问题。

### 子序列的和

输入两个正整数n＜m＜10 6 ，输出 ，保留5位小数。输入包含多组数据，
结束标记为n＝m＝0。提示：本题有陷阱。
样例输入：
2 4
65536 655360
0 0
样例输出：
Case 1: 0.42361
Case 2: 0.00001

```java
int n = 65536, m = 655360;
double temp = 0;
double sum = 0;
for (int i = n; i <= m; i++) {
    temp = 1.0 / i / i; // 这里不能是 i*i ，是为了防止溢出
    sum += temp;
}
if(sum < 1/1e-6){
    System.out.println();
}
System.out.printf("%.5f",sum);
```



### 排序

用1，2，3，…，9组成3个三位数abc，def和ghi，每个数字恰好使用一次，要
求abc：def：ghi＝1：2：3。按照“abc def ghi”的格式输出所有解，每行一个解。提示：不必
太动脑筋。

```c++
// 习题2-10 样例（permutation）
#include <stdio.h>
int main(void)
{
	int x, y, z, a[10] = {0};
	for(x = 100; x < 333; x++)
	{
		y = 2*x;
		z = 3*x;
		//令a[出现的数字] = 1
		a[x/100] = a[x/10%10] = a[x%10] = 1;
		a[y/100] = a[y/10%10] = a[y%10] = 1;
		a[z/100] = a[z/10%10] = a[z%10] = 1;
		int i, s = 0;
		for(i = 1; i < 10; i++)
			s += a[i];
		if(s == 9)
			printf("%d\t%d\t%d\n", x, y, z);
		for(i = 1; i < 10; i++)	//重新赋值为0
			a[i] = 0;
	}
	return 0;
}
```

### 蛇形填数

> 蛇形填数。在n×n方阵里填入1，2，…，n×n，要求填成蛇形。例如，n＝4时方阵为：
>
> 10 11 12  1
> 9   16 13  2
> 8   15 14  3
> 7   6   5   4
> 上面的方阵中，多余的空格只是为了便于观察规律，不必严格输出。n≤8。

原则是：先判断，再移动，而不是走一步以后发现越界了再退回来。这
样，则需要进行“预判”，即是否越界，以及如果继续往下走会不会到达一个已经填过的格子。越界只需判断x+1<n，因为y的值并没有修改；下一个格子是(x+1,y)，因此只需“a[x+1] [y]== 0”，简写成“!a[x+1] [y]”（其中“!”是“逻辑非”运算符）。



