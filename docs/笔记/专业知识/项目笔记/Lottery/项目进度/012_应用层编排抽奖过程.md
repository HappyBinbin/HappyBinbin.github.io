# 应用层编排抽奖过程

应用分支：20220227_happy_applicationActivityProcess

描述：在 application 应用层调用领域服务功能，编排抽奖过程，包括：领取活动、执行抽奖、落库结果，这其中还有一部分待实现的发送 MQ 消息，后续处理

## 学习目的

1. 掌握 application 中流程编排的操作方式
2. 学习事务控制，尤其是在2个表以上，如何用状态、次数等字段，保证幂等性。*就像你的银行卡提现，要有金额扣减、流水单，来保证事务性*
3. 学习各个功能职责分离、串联、聚合的使用，在什么场景使用哪些字段，串联调用上下文信息

## 开发日志

- 分别在两个分库的表 lottery_01.user_take_activity、lottery_02.user_take_activity 中添加 state`【活动单使用状态 0未使用、1已使用】` 状态字段，这个状态字段用于写入中奖信息到 user_strategy_export_000~003 表中时候，两个表可以做一个幂等性的事务。同时还需要加入 strategy_id 策略ID字段，用于处理领取了活动单但执行抽奖失败时，可以继续获取到此抽奖单继续执行抽奖，而不需要重新领取活动。*其实领取活动就像是一种活动镜像信息，可以在控制幂等反复使用*
- 在 lottery-application 模块下新增 process 包用于流程编排，其实它也是 service 服务包是对领域功能的封装，很薄的一层。那么定义成 process 是想大家对流程编排有个概念，一般这一层的处理可以使用可视化的流程编排工具通过拖拽的方式，处理这部分代码的逻辑。
- 学习本章记得更新分支下的最新SQL语句，另外本章节还连带引入了需要MQ、Worker的场景，后续开发到这些功能的时候，会继续完善。

## 编排流程

![image-20220228162630356](https://happychan.oss-cn-shenzhen.aliyuncs.com/img/image-20220228162630356.png)



- 抽奖整个活动过程的流程编排，主要包括：对活动的领取、对抽奖的操作、对中奖结果的存放，以及如何处理发奖，对于发奖流程我们设计为 MQ 触发，后续再补全这部分内容。
- 对于每一个流程节点编排的内容，都是在领域层开发完成的，而应用层只是做最为简单的且很薄的一层。其实这块也很符合目前很多低代码的使用场景，通过界面可视化控制流程编排，生成代码。

## 工程改造

### 领取活动增加判断和返回领取单ID

```java
@Override
public PartakeResult doPartake(PartakeReq req) {
    // 1. 查询是否存在未执行抽奖领取活动单【user_take_activity 存在 state = 0，领取了但抽奖过程失败的，可以直接返回领取结果继续抽奖】
    UserTakeActivityVO userTakeActivityVO = this.queryNoConsumedTakeActivityOrder(req.getActivityId(), req.getuId());
    if (null != userTakeActivityVO) {
        return buildPartakeResult(userTakeActivityVO.getStrategyId(), userTakeActivityVO.getTakeId());
    }
    
    // .....

    // 5. 插入领取活动信息【个人用户把活动信息写入到用户表】
    Long takeId = idGeneratorMap.get(Constants.Ids.SnowFlake).nextId();
    Result grabResult = this.grabActivity(req, activityBillVO, takeId);
    if (!Constants.ResponseCode.SUCCESS.getCode().equals(grabResult.getCode())) {
        return new PartakeResult(grabResult.getCode(), grabResult.getInfo());
    }
    return buildPartakeResult(activityBillVO.getStrategyId(), takeId);
}
```

- 活动领域中主要是领取活动新增加了`第1步的查询流程`和`修改第5步返回 takeId`
- 查询是否存在未执行抽奖领取活动单。在SQL查询当前活动ID，用户最早领取但未消费的一条记录【这部分一般会有业务流程限制，比如是否处理最先还是最新领取单，要根据自己的业务实际场景进行处理】
- this.grabActivity 方法，用户领取活动时候，新增记录：strategy_id、state 两个字段，这两个字段就是为了处理用户对领取镜像记录的二次处理未执行抽奖的领取单，以及state状态控制事务操作的幂等性

### 库表名称和字段的完善性修改

- 按照分支下的库表语句重新执行即可，主要是新增加了表中的字段以及修改了 user_strategy_export 表名为 000~003

## 抽奖活动流程编排

```java
@Override
public DrawProcessResult doDrawProcess(DrawProcessReq req) {
    // 1. 领取活动
    PartakeResult partakeResult = activityPartake.doPartake(new PartakeReq(req.getuId(), req.getActivityId()));
    if (!Constants.ResponseCode.SUCCESS.getCode().equals(partakeResult.getCode())) {
        return new DrawProcessResult(partakeResult.getCode(), partakeResult.getInfo());
    }
    Long strategyId = partakeResult.getStrategyId();
    Long takeId = partakeResult.getTakeId();

    // 2. 执行抽奖
    DrawResult drawResult = drawExec.doDrawExec(new DrawReq(req.getuId(), strategyId, String.valueOf(takeId)));
    if (Constants.DrawState.FAIL.getCode().equals(drawResult.getDrawState())) {
        return new DrawProcessResult(Constants.ResponseCode.LOSING_DRAW.getCode(), Constants.ResponseCode.LOSING_DRAW.getInfo());
    }
    DrawAwardInfo drawAwardInfo = drawResult.getDrawAwardInfo();

    // 3. 结果落库
    activityPartake.recordDrawOrder(buildDrawOrderVO(req, strategyId, takeId, drawAwardInfo));

    // 4. 发送MQ，触发发奖流程

    // 5. 返回结果
    return new DrawProcessResult(Constants.ResponseCode.SUCCESS.getCode(), Constants.ResponseCode.SUCCESS.getInfo(), drawAwardInfo);
}

```

- 按照流程图设计，分别进行：领取活动、执行抽奖、结果落库、发送MQ、返回结果，这些步骤的操作。其实这块的流程就相对来说比较简单了，主要是串联起各个抽奖步骤的操作。



## 测试验证

测试点

- 测试活动状态、时间、库存以及个人领取次数超限情况下，返回的状态
- 测试用户领取活动执行抽奖失败，再发起一次抽奖时，读取到未被执行的抽奖单。*可以把抽奖后的结果信息在数据库中删掉，只保留抽奖单，状态设置为0*
- 修改用户可抽奖次数为前一个，删除其他记录信息，验证事务回滚

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class ActivityProcessTest {

    private Logger logger = LoggerFactory.getLogger(ActivityProcessTest.class);

    @Resource
    private IActivityProcess activityProcess;

    @Test
    public void test_doDrawProcess() {
        DrawProcessReq req = new DrawProcessReq();
        req.setuId("fustack");
        req.setActivityId(100001L);
        DrawProcessResult drawProcessResult = activityProcess.doDrawProcess(req);

        logger.info("请求入参：{}", JSON.toJSONString(req));
        logger.info("测试结果：{}", JSON.toJSONString(drawProcessResult));
    }

}
```

**测试结果** - `修改库表活动状态 lottery.activity.state = 1 非活动中`

```java
08:20:42.183  INFO 8804 --- [           main] c.i.l.t.application.ActivityProcessTest  : 请求入参：{"activityId":100001,"uId":"fustack"}
08:20:42.186  INFO 8804 --- [           main] c.i.l.t.application.ActivityProcessTest  : 测试结果：{"code":"0001","info":"活动当前状态非可用"}
```

**测试结果** - `修改库表活动状态 lottery.activity.state = 5 活动中` 也保证其他时间范围、库存充足

```java
08:22:59.745  INFO 9053 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:23:00.138  INFO 9053 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:23:00.159  INFO 9053 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:23:00.284  INFO 9053 --- [           main] c.i.l.d.s.s.draw.impl.DrawExecImpl           : 执行抽奖策略 strategyId：10001，无库存排除奖品列表ID集合 awardList：["1"]
08:23:00.299  INFO 9053 --- [           main] c.i.l.d.s.service.draw.AbstractDrawBase   : 执行策略抽奖完成【已中奖】，用户：fustack 策略ID：10001 奖品ID：2 奖品名称：iphone
08:23:00.302  INFO 9053 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:23:00.310  INFO 9053 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:23:00.354  INFO 9053 --- [           main] c.i.l.t.application.ActivityProcessTest      : 请求入参：{"activityId":100001,"uId":"fustack"}
08:23:00.367  INFO 9053 --- [           main] c.i.l.t.application.ActivityProcessTest      : 测试结果：{"code":"0000","drawAwardInfo":{"awardContent":"Code","awardId":"2","awardName":"iphone","awardType":1,"grantType":1,"strategyMode":2},"info":"成功"}
```

- 这是正常情况下的抽奖执行结果，活动时间可用、状态可用、库存充足、个人领取次数有剩余

**测试结果** - `修改 lottery_02.user_take_activity_count.left_count 剩余次数为前一个，也就是增加一个。这样在领取活动，生成的领域防重UUID策略次数，就会发生冲突，验证事务回滚`

```java
08:30:44.857  INFO 9822 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:30:45.253  INFO 9822 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:30:45.273  INFO 9822 --- [           main] c.b.m.db.router.DBRouterJoinPoint        : 数据库路由 dbIdx：2 tbIdx：0
08:30:45.365 ERROR 9822 --- [           main] c.i.l.d.a.s.p.impl.ActivityPartakeImpl   : 领取活动，唯一索引冲突 activityId：100001 uId：fustack

org.springframework.dao.DuplicateKeyException: 
### Error updating database.  Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrityConstraintViolationException: Duplicate entry 'fustack_100001_5' for key 'idx_uuid'
```

- 修改 left_count 从`5次`修改为`6次`，这样就可以在生成一个表 user_take_activity.uuid 为 'fustack_100001_5' 的唯一值，这样就会发生索引冲突回滚，那么扣减了 user_take_activity_count.left_count 次数就会恢复回去。











