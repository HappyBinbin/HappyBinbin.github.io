# [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

难度中等

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`



## 预备知识

### 何为字典序？

**字典序（dictionary order）**，又称 **字母序（alphabetical order）**，原意是表示英文单词在字典中的先后顺序，在计算机领域中扩展成两个任意字符串的大小关系。

在计算机领域中，这个字典序就不仅仅用来比较英文单词了，而是比较任意字符串。对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。比如`ah1x`小于`ahb`，而`Z5`小于`a3`

ASCII码从小到大为： 数字 < 大写字母 < 小写字母

知道了何为字典序后，还需要知道字典序法

## 字典序法

### 字典序全排列问题

示例：`1 2 3`的全排列如下：

```c
1 2 3 | 1 3 2 | 2 1 3 | 2 3 1 | 3 1 2 | 3 2 1
```

那么什么是字典序法呢？

从上面的全排列也可以看出来了，从左往右依次增大，对这就是字典序法。可是如何用算法来实现字典序法全排列呢？

**字典排序：**

1. 第一步：从右至左找第一个左邻小于右邻的数，记下位置i，值list[a]
2. 第二步：从右边往左找第一个右边大于list[a]的第一个值，记下位置j，值list[b] 
3. 第三步：交换list[a]和list[b]的值
4. 第四步：将i以后的元素重新按从小到大的顺序排列

我们再来看一段文字描述：（用字典序法找124653的下一个排列）

- 如果当前排列是124653，找它的下一个排列的方法是，从这个序列中从右至左找第一个左邻小于右邻的数
- 如果找不到，则所有排列求解完成，如果找得到则说明排列未完成
- 本例中将找到46，计4所在的位置为i,找到后不能直接将46位置互换，而又要从右到左到第一个比4大的数
- 本例找到的数是5，其位置计为j，将i与j所在元素交换125643
    - 然后将i+1至最后一个元素从小到大排序得到125346，这就是124653的下一个排列

下图是用字典序法找`1 2 3`的全排列（全过程）：

![image-20210514154317740](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/20210514154319.png)

## 解法1：

按照字典序给的步骤进行模拟即可解答

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int len = nums.length;
        boolean flag = true;
        int index = -1;
        for(int j = len-1; j > 0;){
            if(nums[j-1] < nums[j]){
                //找到第一个左邻小于右邻的数，记录为index
                flag = false;
                index = j-1;
                for(int k = len-1; k >= 0; k--){
                    //找到第一个比nums[index]大的数
                    if(nums[k] > nums[index]){
                        //与index进行交换
                        int temp = nums[index];
                        nums[index] = nums[k];
                        nums[k] = temp;
                        break;
                    }
                }
                //从index+1开始，进行从小到大排序
                Arrays.sort(nums,index+1,len);
                break;
            }else{
                 j--;
            }
        }
        if(flag){
            //如果为true，则没有找到
            //进行排序即可
            Arrays.sort(nums);
        }
    }
}
```

