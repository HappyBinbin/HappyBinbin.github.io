

## Algorithm

442.数组中重复的数据

```shell
给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。

你必须设计并实现一个时间复杂度为 O(n) 且仅使用常量额外空间的算法解决此问题。

示例 1：

输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
```

### 思路一

先排序，然后for循环就能找出来，但是排序会使用到额外的空间，因此需要考虑常量空间的算法；

数组长度为n，并且数组内的所有整数都在[1, n]内，且每个整数只会出现 1 或 2 次。那么如果我们按照整数的大小，将其放到对应数组的位置上：

- 如果 i 恰好出现了一次，那么将 i 放在数组中下标为 i−1 的位置即可
- 如果 i 出现了两次，那么我们希望其中的一个 i 放在数组下标中为 i−1 的位置，另一个 i 放置在任意「不冲突」的位置 j。也就是说，数 j+1 没有在数组中出现过

这样我们只需要遍历一遍，就能按照上述规则存放没一个数字，当遍历到 i 位置时，如果发现 nums[i] - 1 ≠ i，说明 nums[i] 出现了两次，则可以加入到结果集里面

注意：

- 每个整数只会出现 1 或 2 次；这个条件很重要，如果出现2次以上，该算法无法识别重复数组出现的次数，答案中会存在重复的整数；可以使用额外的空间去去重；

### 题目变种

如果在不让改变原有数组的情况下，还使用常量空间找出重复的数字，应该怎么做?

可以通过二分法来寻找重复数字，数组内的整数取值范围是 [1, n-1] ，而数组的范围是 n；题目有所改变。在这个限制条件下，因为整数取值范围小于数组能容纳的数量，因此必然存在重复数字；我们可以取 1-n 中间的数字，例如 [1-7]，划分为 [1-4], [5-7]，然后遍历数组，判断 [1-4]的每个数组在数组中出现的次数，如果发现其中某一个数字出现了两次，则重复的数字必然在 [1-4] 而不是 [5-7]；可以排除掉另外一半数组；然后继续二分查询，直到最后找到重复的数字；

注意：

- 该算法只能找到某一个重复的数字，而不能找到全部的
- 算法复杂度上存在牺牲，二分为 n * log(n)

## Review



## Tip



## Share



