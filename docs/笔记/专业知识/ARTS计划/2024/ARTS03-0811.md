

## Algorithm

### [LCR 121. 寻找目标值 - 二维数组](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```markdown
m*n 的二维数组 plants 记录了园林景观的植物排布情况，具有以下特性：

每行中，每棵植物的右侧相邻植物不矮于该植物；
每列中，每棵植物的下侧相邻植物不矮于该植物。

示例 1：

输入：plants = [[2,3,6,8],[4,5,8,9],[5,9,10,12]], target = 8

输出：true
 

示例 2：

输入：plants = [[1,3,5],[2,5,7]], target = 4

输出：false
```

#### **思路**

- 分治法，从左下角或者右上角开始比较，可以发现，如果 target 大于 目标值，则可以排除所在行，如果target小于目标值，则可以排除所在列。这样每次都能排除一行或者一列，最终就能找到target或者遍历完所有的数

### [LCR 122. 路径加密](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

```
假定一段路径记作字符串 path，其中以 "." 作为分隔符。现需将路径加密，加密方法为将 path 中的分隔符替换为空格 " "，请返回加密后的字符串。


示例 1：

输入：path = "a.aef.qerf.bb"

输出："a aef qerf bb"
 

限制：

0 <= path.length <= 10000
```

#### 思路

在目前的题目条件下，可以直接遍历替换即可，空间和时间复杂度为 O(n)

### 变种

```
示例 1：

输入：path = "a aef qerf bb"

输出："a%20aef%20qerf%20bb"

要求：
使用常量的空间复杂度，时间复杂度要求为 O(n)
```

#### 思路

不同点：

- 需要替换的字符变多了，替换完后，整体字符串的长度是增加的；即需要重新分配内存空间；
- 要求使用常量的空间复杂度

如果还是按照遍历的思路，发现空格就替换，则每次替换后，都需要重新为后面的字符分配内存空间，否则path的字符串长度是不够的，这就会导致多次的重复分配地址的操作；所以我们可以先遍历一遍，统计有多少个需要替换的空格，从而计算出最终所需的字符串长度；计算方法：[原来的长度] + [空格数 * 每替换一个空格增加的长度]。

这样就能避免重复分配内存的操作，但是按照这个思路，假设字符串长度为 n，对于每个空格字符，都需要移动后面 O(n) 个字符，即整体复杂度为 O(n^2)；

#### 优化

双指针，p1指向原始字符串的末尾，p2指向替换后的字符串的末尾，移动p1，将其指向的字符，替换到p2的位置，并移动p2，直到遇到空格；遇到空格后，在p2前插入 %20，p2移动三个位置，p1还是移动一格；继续重复操作，直到p1、p2相遇；

这样减少了重复字符的移动次数，时间复杂度就为 O(n)



## Review



## Tip



## Share

websocket 产生背景、应用场景、与HTTP的不同

