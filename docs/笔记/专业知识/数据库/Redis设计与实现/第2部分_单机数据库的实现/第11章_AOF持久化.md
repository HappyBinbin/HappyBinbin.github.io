# 11. AOF持久化

RDB持久化记录的是数据库本身，而AOF(Append Only File)则**记录Redis服务器所执行的写命令**。

[![img](https://camo.githubusercontent.com/483924da32780464e27fa46f24815324e8043eb88cfe7aad20e86e23cd008e55/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130353131313535322e706e67)](https://camo.githubusercontent.com/483924da32780464e27fa46f24815324e8043eb88cfe7aad20e86e23cd008e55/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130353131313535322e706e67)

假如使用如下命令:

```sql
redis> SET msg "hello"
OK
```

则AOF记录形式如下：

```tex
*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n
*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n
```

## 11.1 AOF持久化的实现

AOF如其名所示，Append Only File，AOF持久化功能的实现可以分为**命令追加（append）、文件写入与同步（sync）**

### 11.1.1 命令追加

如果AOF被打开，则服务器执行完一个命令后，会以协议格式将命令**追加到服务器状态aof_buf缓冲区的结尾**：

```c
struct redisServer 
{ 
    // ...  
    sds aof_buf;     // AOF缓冲区
    // ...
};
```

比如执行了`SET KEY VALUE`后，会将以下协议内容加载到aof_buf缓冲区：

```
*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n
```

### 11.1.2 AOF文件的写入与同步

Redis的服务器进程就是一个**事件循环（loop）**，这个循环中的**文件事件**负责接收客户端的命令请求，**以及向客户端发送命令回复**，而**时间事件**则负责执行像`serverCron`函数这样需要定时运行的函数。

服务器每次结束一个事件循环之前，它都会调用`flushAppendOnlyFile`函数，**考虑是否需要将`aof_buf`缓冲区中的内容写入和保存到AOF文件里面**。

![img](https://camo.githubusercontent.com/13ec44b23d2594190b68c6b02a44e8435c76bc26ffc9dea6cc37028c3046494b/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130353132303031332e706e67)

这个函数的行为有服务器配置的`appendfsync`选项来设置，默认为`everysec`：

[![img](https://camo.githubusercontent.com/26e2b906480181a6c8320c67de6f4e0d7058f0277382810a97f0548ccfe353a7/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130353132303232342e706e67)](https://camo.githubusercontent.com/26e2b906480181a6c8320c67de6f4e0d7058f0277382810a97f0548ccfe353a7/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130353132303232342e706e67)

默认情况下，距离上次同步过了一秒钟，则服务器会将aof_buf内容写入AOF文件中。

- always，AOF最多只会丢失一个事件循环中所产生的命令数据
- everyse，AOF最多只会丢失一秒的命令数据
- no，AOF最多会丢失上次同步之后的所有命令数据

## 11.2 AOF文件的载入与数据还原

因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要**读入并重新执行一遍AOF文件里面保存的写命令**，就可以还原服务器关闭之前的数据库状态。

AOF还原数据库的步骤如下：

1. 创建一个不带网络连接的**伪客户端（fake client）**：因为Redis的命令只能在客户端上下文中执行。
2. 从AOF中读出一条命令。
3. 使用伪客户端执行被读出的写命令。
4. 重复23步

## 11.3 AOF重写

随着时间的增长，AOF文件的大小将会越来越大。为了解决这个问题，Redis提供了**AOF重写**功能。

重写后，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个**AOF文件保存的数据库状态完全相同**。

如果要保存一个键值对，我们其实只关心它当前的状态。所以重写策略是：首先**从数据库中读取键现在的值，然后用一条命令去记录键值对**，用到了`aof_rewrite`函数。

比如，对list进行`RPUSH`操作填入"A"、"B"、"C"，然后再`LPOP`一次，我们操作了4次，但其实用`RPUSH list A B C`这一条指令就可以代替。

`aof_rewrite`函数包含了大量写入操作，调用时会导致线程被长时间阻塞，所以Redis**将AOF重写放入子进程里**。

<hr>

还有一个问题：子进程AOF重写时，主进程也在写命令，导致两者状态不一致。因此，**Redis服务器设置了一个AOF重写缓冲区**，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会**同时**将这个写命令发送给**AOF缓冲区**和**AOF重写缓冲区**。

换句话说，子进程执行AOF期间，服务器进程需要：

- 执行客户端指令
- 将执行后的命令追加到AOF缓冲区
- 将执行后的命令追加到AOF重写缓冲区

<hr>

子进程执行完AOF后，向父进程发送一个信号。父进程接收后：

1. 将AOF重写缓冲区的内容写入AOF文件中，保证一致性。
2. 对新AOF文件改名，原子的(atomic)覆盖现有AOF文件。

在整个AOF后台重写过程中，**只有信号处理函数执行时会对服务器进程（父进程）造成阻塞**，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。
