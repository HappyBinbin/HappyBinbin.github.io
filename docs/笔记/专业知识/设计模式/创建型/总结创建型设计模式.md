# 总结创建型设计模式

创建者模式一共五种，加上工厂方法的话一共六种设计模式

- 单例模式
- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式
- 原型模式
- 建造者模式

其中比较难理解的就是三个工厂模式

我认为学明白这三个工厂模式，需要清楚以下几点

- 为什么会有这几种模式？
- 每个模式之间的区别是什么？怎么演进的？
- 它们的优缺点是什么？适用于什么场景？





## 我学到了什么

- 了解了产品簇与产品等级的概念
- 简单工厂模式主要是为了将客户端与创建对象这个过程进行解耦，所以刚开始有简单工厂，独立出一个工厂类来负责创建对象的职责，将创建对象与使用对象两者分离，达到单一职责的效果；
- 由于简单工厂模式的所有产品都由一个工厂负责生产，这样造成了每次新增产品都必须修改工厂，违背了开闭原则，也不利于扩展和维护。所以将创建产品的方法抽象出一个抽象工厂，将具体的产品与具体的工厂进行绑定。这样每次新增产品时，只需要去新增具体工厂与具体产品类即可。这就是工厂方法模式
- 但是工厂方法模式也有弊端，就是每次新增产品，类都会成对增加，可能会造成类爆炸的问题。所以考虑将一些相关的产品组合成一个”产品族“，由一个工厂同一生产。也就是说工厂方法的注意面是单个产品等级结构，而抽象工厂的注意面是多个产品等级结构。这样可以有效减少类的增加。
- 抽象工厂模式具有“开闭原则”的倾斜性，即它非常支持增加产品族，而对于增加或者删除产品等级结构则不予开放

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20220129115345408.png" alt="image-20220129115345408" style="zoom:80%;" />



- 单例模式的八种写法
    - 饿汉式（不管用不用，先加载），静态常量、静态代码块
    - 饿汉式（用到才加载），线程不安全、线程安全（同步方法），线程安全（同步代码块）、双重检查
    - 静态内部类、枚举类
- 原型模式，知道了浅克隆和深克隆的区别以及实现方式
    - 浅克隆，直接调用父类的 clone 方法即可
    - 深克隆，需要重写 clone 方法，完成对非基本数据类型的复制；或者利用反射机制，进行深克隆
    - 可以利用 HashMap，做成一个原型管理器，来负责添加和查找返回对应的对象类型
- 建造者模式，这个模式与模板方法模式、抽象工厂有一定的类似之处
    - 与模板方法的区别，模板方法注重的是行为，而不是创建对象
    - 与抽象工厂的区别，抽象工厂注重的是一系列的产品，更像是一个生产工厂，而建造者则是组装一系列的产品，更像是一个组装工厂







