# 创建对象与使用对象的理解

## Reference

[1]  https://blog.csdn.net/lovelion/article/details/7523392

与一个对象相关的职责：

- 本身具有的职责
- 创建对象的职责
- 使用对象的职责

本身具有的职责，就是对象自身所具有的一些数据和行为，可以通过一些公开方法来实现它的职责。

## 创建职责与使用职责

Java 中创建对象的几种方式：

- 使用 new 关键字直接创建
- 通过反射机制创建
- 通过 clone( ) 方法创建
- 通过工厂类创建

使用 new 直接创建对象时最简单的，但是其灵活性较差。

```java
class LoginAction {
    private UserDAO udao;

    public LoginAction() {
        udao = new JDBCUserDAO(); //创建对象
    }

    public void execute() {
        //其他代码
        udao.findUserById(); //使用对象
        //其他代码
    }
}
```

在 LoginAction 类中定义了一个 UserDao 对象 udao，构造方法中又创建了 JDBCUserDAO 对象，并且在 execute( ) 方法中使用了该对象的方法。

分析一下这段代码中，LoginAction 与 UserDAO 之间的关系，LoginAction 即负责创建 udao 又负责 udao 的使用，创建对象与使用对象的职责耦合在一起，这样的设计会导致一个很严重的问题。

> 如果再 LoginAction 中希望使用 UserDAO 的另一个子类 HibernateDAO 类型的对象，则必须要修改 LoginAction 的源代码，违反了 “开闭原则”

最常用的一种解决办法就是将 udao 对象的创建职责从 LoginAction 类中移除，通过工厂类来负责创建。是的客户类（LoginAction）与对象的创建解耦，而工厂类也不涉及对象类的使用。

![image-20220114181932465](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20220114181932465.png)

工厂类的引入降低了因为产品或者工厂类改变所造成的维护工作量，如果 UserDAO 的某个子类的构造函数发生改变或者需要添加或移除不同的子类，只要维护 UserDAOFactory 的代码即可。而如果 UserDAO 的接口发生改变，只需要 LoginAction 的代码即可。

在所有的工厂模式中，我们都强调一点：**两个类 A 和 B 之间的关系应该仅仅是 A 创建 B 或者 A 使用 B，而不能两种关系都有**。将对象的创建和使用分离，也使得系统更加符合“单一职责原则”，有利于对功能的复用和系统的维护。

将对象的创建和使用分离还有一个好处：**防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中**。因为有时候我们创建一个对象不只是简单调用其构造函数，还需要设置一些参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入工厂类来封装对象的创建逻辑和客户代码的实例化/配置选项。

使用工厂类还有一个“不是特别明显的”优点，一个类可能拥有多个构造函数，而在Java、C#等语言中构造函数名字都与类名相同，客户端只能通过传入不同的参数来调用不同的构造函数创建对象，从构造函数和参数列表中也许大家根本不了解不同构造函数所构造的产品的差异。但如果将对象的创建过程封装在工厂类中，**我们可以提供一系列名字完全不同的工厂方法，每一个工厂方法对应一个构造函数**，客户端可以以一种更加可读、易懂的方式来创建对象，而且，从一组工厂方法中选择一个意义明确的工厂方法，比从一组名称相同参数不同的构造函数中选择一个构造函数要方便很多。如图所示：

![image-20220114183859932](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20220114183859932.png)

在图2中，矩形工厂类RectangleFactory提供了两个工厂方法createRectangle()和createSquare()，一个用于创建长方形，一个用于创建正方形，这两个方法比直接通过构造函数来创建长方形或正方形对象意义更加明确，也在一定程度上降低了客户端调用时出错的概率。

那么，有人可能会问，是否需要为设计中的每一个类都配备一个工厂类？

答案是：具体情况具体分析。如果产品类很简单，而且不存在太多变数，其构造过程也很简单，此时无须为其提供工厂类，直接在使用之前实例化即可，例如Java语言中的String类，我们就无须为它专门提供一个StringFactory，这样做反而有点像杀鸡用牛刀，大材小用，而且会导致工厂泛滥，增加系统的复杂度。























