# 迭代器模式

## Reference

[1] https://bugstack.cn/md/develop/design-pattern

[2] http://c.biancheng.net/view/1397.html

[3] https://refactoringguru.cn/design-patterns/visitor/java/example

[4] https://cmsblogs.com/article/1407700262654709760

[5] https://blog.csdn.net/lovelion

## 什么是迭代器模式？

> 迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

## 问题

大部分集合使用简单列表存储元素。 但有些集合还会使用栈、 树、 图和其他复杂的数据结构。

无论集合的构成方式如何， 它都必须提供某种访问元素的方式， 便于其他代码使用其中的元素。 集合应提供一种能够遍历元素的方式， 且保证它不会周而复始地访问同一个元素。

如果你的集合基于列表， 那么这项工作听上去仿佛很简单。 但如何遍历复杂数据结构 （例如树） 中的元素呢？ 例如， 今天你需要使用深度优先算法来遍历树结构， 明天可能会需要广度优先算法； 下周则可能会需要其他方式 （比如随机存取树中的元素）。

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20211220155828032.png" alt="image-20211220155828032" style="zoom:80%;" />

不断向集合中添加遍历算法会模糊其 “高效存储数据” 的主要职责。 此外， 有些算法可能是根据特定应用订制的， 将其加入泛型集合类中会显得非常奇怪。

## 解决方法

迭代器模式的主要思想是将集合的遍历行为抽取为单独的*迭代器*对象。

所有迭代器必须实现相同的接口。 这样一来， 只要有合适的迭代器， 客户端代码就能兼容任何类型的集合或遍历算法。 如果你需要采用特殊方式来遍历集合， 只需创建一个新的迭代器类即可， 无需对集合或客户端进行修改。

## 迭代器结构

1. 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。
2. 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。
3. 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。
4. 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。



<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20211220155256954.png" alt="image-20211220155256954" style="zoom:80%;" />

## 案例

参考 JDK 中的 Iterator 即可

## 小结

- 迭代器设计模式的优点是可以让我们以相同的方式，遍历不同的数据结构元素，这些数据结构包括；`数组`、`链表`、`树`等，而用户在使用遍历的时候并不需要去关心每一种数据结构的遍历处理逻辑，从让使用变得统一易用。

## 进阶阅读

如果您想了解迭代器模式在框架源码中的应用，可猛击阅读以下文章。

- [《迭代器模式在JDK源码中的应用》](http://c.biancheng.net/view/vip_8497.html)
- [《迭代器模式在MyBatis源码中的应用》](http://c.biancheng.net/view/vip_8498.html)