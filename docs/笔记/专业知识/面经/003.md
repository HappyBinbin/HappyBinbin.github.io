[TOC]


## 1.static 和 volatile

在java中声明一个静态变量，意味着只有一个副本，无论创建了多少个类的对象，即使没有创建对象，变量也可以访问，但是线程可能具有本地缓存的值。

当变量volatile而不是静态时，每个object都有一个变量，所以，表面看来，与正常变量没有区别，但是与静态完全不同。然而，即使使用object字段，线程也可能在本地缓存变量值。

这意味着如果两个线程同时更新同一个对象的变量，并且该变量未被声明为volatile，则可能存在一个线程在缓存中具有旧值的情况。

即使你通过多个线程访问静态值，每个线程都可以具有本地缓存副本，为了避免这种情况，可以将变量申明为静态volatile，这将强制线程每次读取全局值，但是volatile并不能代替正确的同步！



## 2.如何实现UDP的可靠传输？

传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。

实现确认机制、重传机制、窗口确认机制。

发送：包的分片、包确认、包的重发

接收：包的调序、包的序号确认

**最简单的方式是在**应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。

- 1、添加seq/ack机制，确保数据发送到对端
- 2、添加发送和接收缓冲区，主要是用户超时重传。
- 3、添加超时重传机制。

详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。

目前有如下开源程序利用udp实现了可靠的数据传输。分别为***RUDP、RTP、UDT\***

## 3. 进程和线程的区别

- 进程是资源分配的最小单位，线程是程序执行的最小单位。
- 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
- 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
- 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

