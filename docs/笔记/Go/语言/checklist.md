# Go CheckList

## Mark





5.1 struct 结构体

- 初始化结构体时，请使用 &T{} 替代 new(T)，以使其与结构体初始化一致
- 建议使用接口实现多态
- 结构体初始化时使用标签语法，避免结构体新增字段时导致已有代码编译错误



5.2 slice 切片

- 不使用数组作为参数，而使用切片。因为数组作为值传递会拷贝
- 切片形参不使用指针传递，如果函数需要向切片追加东西，则可以将修改后的切片作为返回值返回
- nil 是一个有效的长度为 0 的 slice，应该使用 nil 来替代 长度为 0 的 slice
- 检查切片是否为空 len(slice) == 0，而非 nil
- 零值切片（var 声明的切片）可立即使用，不需要调用 make( )
- 从切片中创建新切片时，需要注意内存泄露，因为原因切片内存还没释放
- 减少在结构体中使用 slice 和 map，因为 slice 和 map 是浅拷贝，容易出错



5.3 map 映射

- 不允许通过零值来判断 map 中的键是否存在
- 使用"seconds, ok = timeZone[tz]"来判断是否存在存在键
- 必须使用 make 初始化，尽可能提供容量信息
- 为访问 map 提供 getter 和 setter 方法



5.4 channel 管道

- 



5.6 init 初始化函数

- init 不能被其他函数调用，而是在main执行前被执行调用
- 每个包可以有多个init 函数，



5.8 函数

- 函数参数 <= 5
- 返回值 <= 3
- 不允许在函数参数中使用布尔类型（包括使用数值类型仿制的布尔类型）
- 避免使用标识参数来控制函数的执行逻辑

```go
func doAorB(flag int) {
    if flag == flagA {
        processA1()
    }
    if flag == flagB {
        processB1()
    }
}
```



5.9 接口

- 接口不需要使用指针
- 当结构体实现了某个接口时，添加编译器校验
- 包之间调用尽量使用接口，而不是具体实现类



5.10 枚举 iota

- 为枚举类型添加 string 方法，解释含义
- 让 iota 从 a+1 开始增量，因为go中默认变量初始化为 0





## 不懂

5.11 - Go/language/cgo --- C混合编程