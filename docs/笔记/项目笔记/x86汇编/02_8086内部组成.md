# 学习目标

- 8086 处理器的内部组成
- 各个寄存器的作用与使用方法

# 8086处理器内部组成

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/202111031221761.png" alt="image-20211103122125528" style="zoom: 50%;" />

**8086 CPU** **中寄存器总共为** **14** **个，且均为** **16** **位。**

即 AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES 共 14 个。而这 14 个寄存器按照一定方式又分为了通用寄存器，控制寄存器和段寄存器。



## 1、指令队列缓冲器

指令队列缓冲器，又名：指令预取队列。什么意思呢？就是当你的CPU在忙于做其他事情（一般是指执行那些不需要去内存中取的指令）而并没有去内存中取指令执行时，此时指令队列缓冲器（指令预取队列）就会去内存中取出6个字节的指令放到指令队列缓冲器，那么当CPU该执行内存中的指令时，它就会就近向指令队列缓冲器中去取指令，这样的话就会比去内存中取指令要快很多，毕竟内存还是通过外部总线与内存条相连接的。



## 2、**通用寄存器**

**AX，BX，CX，DX 称作为数据寄存器：**

- AX (Accumulator)：累加寄存器，也称之为累加器
- BX (Base)：基地址寄存器
- CX (Count)：计数器寄存器
- DX (Data)：数据寄存器



**SP和BP又称作为指针寄存器：**

- SP (Stack Pointer)：堆栈指针寄存器；
- BP (Base Pointer)：基指针寄存器；



**SI和DI又称作为变址寄存器：**

- SI (Source Index)：源变址寄存器；
- DI (Destination Index)：目的变址寄存器；



**控制寄存器：**

- IP (Instruction Pointer)：指令指针寄存器；
- FLAG：标志寄存器；



**段寄存器：**

- CS (Code Segment)：代码段寄存器；
- DS (Data Segment)：数据段寄存器；
- SS (Stack Segment)：堆栈段寄存器；
- ES (Extra Segment)：附加段寄存器；



## 作用和使用方式

**数据寄存器（AX，BX，CX，DX）**

数据寄存器有 AX，BX，CX，DX 四个组成，由于在 8086 之前的 CPU 为 8 位 CPU，所以为了兼容以前的 8 位程序，在 8086 CPU 中，每一个数据寄存器都可以当做两个单独的寄存器来使用，由此，每一个 16 位寄存器就可以当做 2 个独立的 8 位寄存器来使用了。

AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；

BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；

CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；

DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；

除了上面 4 个数据寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器 ；

### **AX 寄存器**

如上所说，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL，可以有以下代码(即将 AX当做普通的寄存器使用，即可以用来暂存数据)：

```assembly
MOV AX,1234H ;向寄存器 AX 传入数据 1234H

MOV AH,56H ;向寄存器 AX 的高 8 位寄存器 AH 中传入数据 56H

MOV AL,78H ;向寄存器 AX 的低 8 位寄存器 AL 中传入数据 78H
```

既然 AX 又被称作为累加器，AX 寄存器还具有特殊的用途，其可以在使用 DIV 和 MUL 指令时使用

- DIV 在 8086 CPU 中是除法指令，而在使用除法的时候有两种情况，即除数可以是 8 位或者是 16 位的。除数可以存放在寄存器中或者是内存单元中，被除数放在AX中。
  - 当除数是 8 位时，被除数一定会是 16 位的，并且默认是放在 AX 寄存器中；而当除数是 16 位时，被除数一定是 32 位的，其中高16位放到DX中，低16位放在AX中。
  - 当除法指令执行完成以后，如果除数是 8 位的，则在 AL 中会保存此次除法操作的商，而在 AH 中则会保存此次除法操作的余数；如果除数是 16 位的话，则 AX 中会保存本次除法操作的商，而 DX 则保存本次除法操作的余数。
- MUL 在8086CPU中是乘法指令，在做乘法运算时，两个相乘的数要么都是 8 位，要么都是 16 位。
  - 如果两个相乘的数都是 8 位的话，则一个默认是放在 AL 中，而另一个 8 位的乘数则位于其他的寄存器或者说是内存字节单元中；如果两个相乘的数都是 16 位的话，则一个默认存放在 AX 中，另一个则是某个寄存器中或者是某个内存字单元中。
  - 当 MUL 指令执行完毕后，如果是 8 位的乘法运算，则默认乘法运算的结果是保存在 AX 中；如果是 16 位的乘法运算的话，则默认乘法运算的结果有 32 位，其中高位默认保存在 DX 中，而低位则默认保存在 AX 中。

AX 寄存器在 DIV 指令中的使用：

```assembly
MOV DX,0H ;设置 32 位被除数的高 16 位为 0H

MOV AX,8H ;设置 32 位被除数的低 16 位为 8H

MOV BX,2H ;设置 16 位除数为 2H

DIV BX ;执行计算
```

AX 寄存器在 MUL 指令中的使用：

```assembly
MOV AX,800H ;设置 16 位乘数为 800H

MOV BX,100H ;设置 16 位乘数为 100H

MOV DX,0H ;清空用来保存乘法结果的高16 位

MUL BX ;执行计算
```



### **BX寄存器**

首先可以明确的是，BX 作为数据寄存器，表明其是可以暂存一般的数据的，即在某种程度上，它和 AX 可以暂存一般性数据的功能是一样的，其同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即 BH 和 BL。除了暂存一般性数据的功能外，BX 作为通用寄存器的一种，BX 主要还是用于其专属功能——寻址(物理内存地址)上。8086中的地址表示是**段地址:[偏移]**，段地址可省略，省略时取默认情况。内存大小1MB,20位地址。

BX 寄存器在寻址中的使用：

MOV BX,5H

MOV AH,[BX] 设置 AX 的值为偏移地址为 BX 的内存单元中的值(此时默认DS段)



### **CX 寄存器**

CX 寄存器作为数据寄存器的一种呢，其同样具有和AX，BX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，即CH 和 CL 两个 8 位寄存器，当然，CX 也是有其专门的用途的，CX 中的 C 被翻译为 Counting 也就是计数器的功能，当在汇编指令中使用循环 LOOP 指令时，可以通过 CX 来指定需要循环的次数，而 CPU 在每一次执行 LOOP 指令的时候，都会做两件事：一件就是令 CX = CX – 1，即令 CX 计数器自动减去 1；还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令。

CX 寄存器在循环中的使用(输出 5 个白底蓝字的 A)：

```assembly
MOV AX,0B800H

MOV DS,AX ;使用 80x25 彩色字符模式，内存地址0xB8000 - 0xBFFFFF

MOV BX,0 ;从 0xB8000 开始

MOV CX,5H ;循环 5 次（**每次运行到loop就减一**）

MOV DX,41H ;A的16 进制为 41H

MOV AX,01110001B ;显示白底蓝字

s: MOV [BX],DX ;显示 ASCII 字符

ADD BX,1

MOV [BX],AX ;设置字符显示属性

ADD BX,1

LOOP s
```



### **DX寄存器**

DX 寄存器作为数据寄存器的一种，同样具有和AX，BX，CX 一样的特点，即可以暂存一般性的数据，同时还可以将其当做两个独立的 8 位寄存器使用，有 DH 和 DL，同时，DX 作为一个通用寄存器，当在使用 DIV 指令进行除法运算时，如果除数为 16 位时，被除数将会是 32 位，而被除数的高 16 位就是存放在 DX 中，执行完 DIV 指令后，本次除法运算所产生的余数将会保存在 DX 中；在执行 MUL 指令时，如果两个相乘的数都是 16 位的话，相乘后产生的结果显然需要 32 位来保存，而这 32 位的结果的高 16 位就是存放在 DX 寄存器中。

DX 寄存器在 DIV 指令中的使用（即 2293812 / 256 = 8960 余数为 52）：

```assembly
MOV DX,0023H ;32 位被除数的高 16 位

MOV AX,0034H ;32 位被除数的低 16 位

MOV BX,100H ;16的除数

DIV BX
```



### **指针寄存器（BP，SP）**

8086 CPU 中的指针寄存器包括两个，SP 和 BP，因为 SP 寄存器实质上必须和 SS 段寄存器一起使用，所以，把 SP 寄存器留到后面和 SS 段寄存器一起作介绍。

**BP也就是基指针寄存器**，它和其他的几个用来进行寻址操作所使用的寄存器(还有 BX，SI，DI)没有太大的区别。首先，BP 寄存器作为通用寄存器的一种，说明其是可以暂存数据的，而后，BP 又不是数据寄存器，也就意味着其不能分割成 2 个独立的 8 位寄存器使用。

当以 […] 的方式访问内存单元而且在 […] 中使用了寄存器 BP 的话，如果在指令中**没有明确或者说是显示的给出段地址时, 段地址使用默认的 SS 寄存器中的值(BX，SI，DI 会默认使用 DS 段寄存器)。**比如 DS:[BP] 则在这里明确给出了段地址位于 DS 中，代表的内存单元即是段地址为 DS ，偏移量为 BP 寄存器中的值的内存单元；而如果是仅使用 [BP] 的话，则代表的内存单元是段地址为 SS，偏移量为 BP 寄存器中的值的内存单元。

在 8086 CPU 中，只有 4 个寄存器可以以 […] 的方式使用，这四个寄存器分别是 BX，SI，DI，BP。BX 寄存器在寻址中的使用：

```assembly
MOV BP,0

MOV AX,[BP] ;将 SS:[BP] 代表的内存单元移入 AX 中

MOV AX,CS:[BP] ;将 CS:[BP] 代表的内存单元移入 AX 中
```



### **变址寄存器（SI，DI）**

首先，变址寄存器和上面介绍的指针寄存器（也就是 BP 和 SP），它们的功能其实都是用于存放某个存储单元地址的偏移，或者是用于某组存储单元开始地址的偏移，即作为存储器指针使用，当然，由于变址寄存器和指针寄存器都是属于通用寄存器，所以它们也可以保存算术结果或者说是具有暂存数据的功能，但是因为它们不是数据寄存器，所以无法分割成 2 个独立的 8 位寄存器使用。

SI 是源变址寄存器，DI 是目的变址寄存器，8086 CPU 中的 SI 寄存器和 DI 寄存器其实和 BX 寄存器的功能是差不多的，只不过 SI 寄存器和 DI 寄存器均不是数据寄存器，所以它们不能够拆分为 2 个独立的 8 位寄存器。同时，通过使用 SI 和 DI 寄存器也可以用来完成寻址操作。

```assembly
MOV SI,0 ;初始化偏移地址为 0

MOV AX,[SI] ;将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX中

MOV AX,DS:[SI] ;将段地址为 DS 偏移地址为 SI 的内存单元中的值移入 AX 中

MOV AX,SS:[SI] ;将段地址为 SS 偏移地址为 SI 的内存单元中的值移入 AX 中
```



### **其他寄存器（CS，IP，SS，SP，DS，ES）**

由于段寄存器总是和其他一些像指针寄存器，变址寄存器，控制寄存器一起使用，所以在这里，不单独介绍段寄存器，而是将段寄存器和一些其他的常用寄存器搭配介绍。



**CS寄存器和IP寄存器**

CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 CS 为代码段寄存器，而 IP 为指令指针寄存器 。**当一个可执行文件加载到内存中以后，CS:IP 两个寄存器便指向了这个可执行文件的起始地址**，然后 CPU 就可以从这个起始地址开始往下读取指令，当读取完指令后，CS:IP 将会自动的改变，基本上是改变 IP，从而指向下一条要读取的指令，这样就可以执行这个可执行文件了。`任何时候，CS:IP 指向的地址中的内容都是 CPU 当前执行的指令。`



**SS寄存器和SP寄存器**

SS:SP 两个寄存器指向的是内存栈的栈顶元素。当使用 PUSH 指令向栈中压入 1 个字节单元时，SP =SP - 1；即栈顶元素会发生变化；当使用 POP 指令从栈中弹出 1 个字节单元时， SP =SP + 1；即栈顶元素会发生变化。



**DS寄存器和ES寄存器**

DS 寄存器和 ES 寄存器都属于段寄存器，其实它们和 CS 寄存器以及 SS 寄存器用起来区别不大，既然是段寄存器的话，自然它们存放的就是某个段地址了。我们知道，CPU 要访问一个内存单元时，必须要提供一个指向这个内存单元的物理地址给 CPU ，而**在 8086 CPU中,物理地址是由段地址左移 4 位(乘以16)后加上偏移地址形成的。**我们也就只需要提供段地址和偏移地址即 OK 。DS寄存器存放的就是数据段的段地址 ，除了BP基指针寄存器外，其余的寄存器都默认使用DS寄存器的值作为段地址。



**标志寄存器（FLAG）**

前面已经介绍了 8086 CPU 14个寄存器中的 13 个了，下面我们将介绍最后一个寄存器也就是 FLAG 寄存器。FLAG 中的每一个位都表示不同的状态，存储的信息通常又被称**作程序状态字（PSW）** 。下面是 FLAG 寄存器中各个位的示意图：

![img](https://pic3.zhimg.com/80/v2-2b6dbe964630ba5a93a6f5fc999b5a66_720w.jpg)

Debug模式下的表示：

![img](https://pic1.zhimg.com/80/v2-8dcc5fbb85ff599a153d4d346da8aa8c_720w.jpg)

