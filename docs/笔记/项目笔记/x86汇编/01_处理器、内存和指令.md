# 学习目标

- 寄存器与算数逻辑部件的简单关系
- 内存储器
- 指令和指令集
- 程序的重定位问题
- 处理器与内存之间的关系
- 内存分段机制

# 1、内存储器

处理器的计算过程实际上是借助于寄存器和算数逻辑部件进行的。那么计算的数据是从哪里来的呢？它是从一个可以保存很多数字的电路，叫做存储器。存储器的种类很多，我们常见的U盘，硬盘，磁盘，内存条，甚至寄存器等都是存储器。

我们这里主要说内存条。由于它通常是和处理器直接相连的，所以叫**内存储器**或者**主存储器**。又或者内存或者主存。和寄存器不同，内存用于保存更多的比特。对应用的最多的个人计算机来说，内存是按字节来组织的，单次访问的最小单位是1字节，这是最基本的存储单元。如下图所示是一个内存和内存访问示意图：

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/202111031214996.png" alt="image-20211103121453928" style="zoom:67%;" />

内存中的每一个字节都对应着一个地址。从0地址开始，由于上面的内存是65536字节，所以该内存的最后一个字节是FFFF（都是用的十六进制表示的）。为了访问一个内存，处理器需要给出一个**地址**。同时访问内存是什么方式？读方式或者写方式，所以处理器需要有一个**读写控制**。如果是写数据，处理器还需要有一个数据传输的控制。最后，处理器单次访问内存时，是以字节为单位访问还是以字为单位访问等，需要有一个**字长控制**来告知。



# 2、指令和指令集

从一开始设计处理器，就是想让它自动工作，另外，还需要提供一种机制，来允许程序员决定进行何种工作。处理器的设计者用某些数来表示该处理器该做什么，这些数，我们称为指令或者叫机器指令。

指令在内存中的布局：

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/202111031217287.png" alt="image-20211103121714217" style="zoom: 80%;" />

指令和非指令的二进制数据是一模一样的，在组成内存的电路中，都是一些高低电平的组合。因为处理器是按顺序取指令，并加以执行的，这样的话，如果指令和数据存放在一起，处理器很容易将数据的二进制当成指令，从而导致错误。所以我们需要将指令与数据分开存放。分别存放在不同的区域。存放指令的区域叫做**代码区**，存放数据的区域叫做**数据区**（这就是为什么进程的虚拟地址空间中代码和数据区分开的原因）。

一个处理器能够识别的指令的集合，称为指令集。

# 3、Intel 8086处理器

## 3.1 程序重定位问题

我们知道，处理器是自动取指令和执行指令的，只要每条指令都正确无误，它就能准确的知道下一条指令的地址。所以，指令必须集中在一起，形成一个段，叫做代码段。
为了做某件事而编写的指令，形成我们所知道的程序。程序中肯定需要操作大量的数据，这大量的数据也应该集中在一起，位于内存中的某个地方，叫做数据段。

假设上面是一个程序片段在内存中的位置，相关指令的用处已经在图中表明。这里不再赘述。但是现在有一个问题，就是我们写的程序（不管是C语言还是C++语言或者Java语言），最终要运行在内存中的位置，是无法确定的。因为你想一想，本身你的电脑中有各种程序在跑了，有qq程序在跑，微信程序在跑，或者还有微博等在跑，他们可能把你的内存都占完了，当你想运行你写的程序的时候，你的程序本想从0100H处开始存放代码段，但是可能这个时候0100H处有其他程序的代码或者指令在运行，此时你的程序只能去另一个位置存放你的代码和数据

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/202111031325510.png" alt="image-20211103132513440" style="zoom: 80%;" />

此时你的程序的代数据段在内存的位置为1000H处，但是你会发现，你的代码段的第一条指令，还是将地址单元0100H处的内容传送到AX寄存器中。但是！！！此时0100H处的内容，并不是我们想要的内容。

产生这种情况的原因就是我们在程序中使用的是绝对内存地址。这样的程序是无法重新定位的。所以我们需要使用另一种方式访问内存：相对地址或者叫做逻辑地址。在任何时候，程序的重定位都是非常棘手的事情。在8086处理器中，这个问题得到解决。它使用了**分段机制。**

## 3.2 内存分段机制

在内存分段中，段，是很多个连续的字节组成的。如图：

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/202111031326514.png" alt="image-20211103132617456"  />

上图有一个7个字节的段。段的起始地址为A532。那么段中的地址从第一个字节开始，他们的地址此时就是段内的偏移地址（0000，0001，0002…）。而他们的实际的物理地址，又恰好等于段地址加上段内的偏移地址。可以用“段地址：偏移地址”，来表示段中的每一个字节的地址。

为了在硬件一级提供对“段地址：偏移地址”的支持。处理器至少要提供两个段寄存器，分别是代码段寄存器CS，数据段寄存器DS。

对代码段CS内容的改变，将导致处理器从新的代码段开始执行。当然，在访问数据之前，也是必须要提前设置好数据段寄存器DS的，使DS之指向数据段。

很重要的一点是，当处理器取指令执行指令的时候，它是把指令中指定的内存地址看成是段内偏移地址的。而不是内存的物理地址。那么当处理器遇到一条访问内存的指令时，它就会将DS中的数据段起始地址加上指令中提供的段内偏移地址得到访问内存所需要的物理地址的。

![image-20211103132742231](https://gitee.com/HappyBinbin/pcigo/raw/master/202111031327305.png)

## 3.3 8086的内存分段机制

8086在进行分段时，并不是每一个地址都可以作为段地址，地址必须是16的倍数，才能作为段地址。因为其地址线是20根，在计算内存的物理地址时，先将段地址先左移4位，然后加上段内偏移地址，这样就可以得到20位的物理地址，就可以将整个1M的地址空间表示完全。

![image-20211103132952659](https://gitee.com/HappyBinbin/pcigo/raw/master/202111031329730.png)































