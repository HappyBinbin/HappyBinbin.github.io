# 14. 服务器

Redis服务器是负责与多个客户端建立网络连接，处理客户端发送的命令请求，在数据里中保存客户端执行命令所产生的的数据，并通过资源管理来维护服务器自身的运转。

## 14.1 命令请求的执行过程

在处理`SET KEY VALUE`的过程中，客户端和服务器共需要执行以下操作：

1. 客户端向服务器发送命令请求`SET KEY VALUE`
2. 服务器接收并处理，产生回复命令OK
3. 服务器发送OK给客户端
4. 客户端接收到命令，并打印给用户

### 14.1.1 发送命令请求

当用户在客户端键入一个请求时，客户端会**将命令请求转换为协议格式**，然后通过套接字发送给服务器。![img](https://camo.githubusercontent.com/defbe2acc5375afabc0a215d1a744922e09175bcd0a6278c383e517247b4c245/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130373130333334342e706e67)

### 14.1.2 读取命令请求

当客户端与服务器之间的连接套接字因为客户端的写入而**变得可读**时，服务器将调用命令请求处理器来执行以下操作：

1. 读取套接字中的协议请求，并保存在客户端状态的输入缓冲区内
2. 分析命令，提取命令参数和个数，存在argv和argc属性中
3. 调用命令执行器

### 14.1.3 命令执行器

前面提到过，命令执行器会在命令表中查找命令，并将找到的结果保存在客户端状态cmd中。

字典的键是一个命令的字符串格式，值则是一个redisCommand结构：

比如set执行时，就会：![img](https://camo.githubusercontent.com/454c5fd0709b8f085079c570d53159b974e71e454a4993502d7e45187d5c34cb/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130373130343035382e706e67)



### 14.1.4 执行预备操作

现在已经成功完成了：连接所需函数，参数，参数个数。但在真正执行之前还需要进行检查：

- 检查客户端状态cmd是否指向NULL
- 根据redisCommand结构的arity属性，检查参数个数是否正确
- 检查身份验证
- 检查内存占用
- 如果当前客户端正在SUBSCRIBE命令订阅频道，则只接受订阅命令，其他命令会被拒绝。
- 服务器因Lua脚本超时并阻塞，服务器只会执行关闭命令，其他会被拒绝。
- 如果客户端正在执行事务，则服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。
- 如果打开了监视器功能，服务器会把将要执行的命令发送给监视器。

### 14.1.5 调用命令的实现函数

在执行命令时，先找到客户端状态指针client，然后找到命令字典cmd，然后查找命令的函数指针proc

```sql
client->cmd->proc(client);
```

![img](https://camo.githubusercontent.com/1d5146a1e9ad859dbfcf0c57bc58a5c55d80e1e20828e11f9a5efe42a0c77dea/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130373130353631332e706e67)

处理完毕后，产生回复，**保存在输出缓冲区里面**，之后实现函数还会为客户端的套接字**关联命令回复处理器**，这个处理器负责将命令回复返回给客户端。![img](https://camo.githubusercontent.com/0870ece2aa617bb3f88af57552f919e5a2f5b5438dd49afc1e4a42e49a7916e6/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130373130353734392e706e67)

### 14.1.6 执行后续工作

执行完实现函数之后，还需要执行一些后续工作：

- 检查慢日志
- 记录命令耗费时长
- 写入AOF缓冲区
- 检查是否有从服务器在复制，是则广播

### 14.1.7 将命令回复发送给客户端

命令实现函数会将命令回复保存在客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行回复处理器，将保存在客户端缓冲区中的命令回复发送给客户端。

### 14.1.8 客户端接收并打印命令回复

当客户端接收到协议格式的命令后，将其转化为人类可读的格式并打印给用户观看

## 14.2 serverCron函数

Redis服务器中的serverCron函数默认每隔100毫秒执行一次，这个函数负责管理服务器的资源，并保持服务器自身的良好运转。severCorn函数的常见功能如下：

### 14.2.1 更新服务器时间缓存

Redis服务器中有不少功能需要**获取系统的当前时间**，而每次获取系统的当前时间都需要执行一次系统调用，**为了减少系统调用的执行次数**，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：

```c
struct redisServer 
{ 
    // ... 
    // 保存了秒级精度的系统当前UNIX时间戳 
    time_t unixtime; 
    // 保存了毫秒级精度的系统当前UNIX时间戳 
    long long mstime;
};
```

因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以**这两个属性记录的时间的精确度并不高**。

- 服务器只会在打印日志、更新服务器LRU时钟、决定是否执行持久化任务等对时间精度要求不高的功能上使用 unixtime 和 mstime
- 对于为键添加过期时间、添加慢日志查询等需要高精度时间的功能来说，服务器还是会再次执行系统调用来获得准确的当前时间

### 14.2.2 更新LRU时钟

服务器状态中的lruclock属性保存了服务器的LRU时钟，这个属性和上面介绍的unixtime属性、mstime属性一样，都是**服务器时间缓存的一种**。

```c
struct redisServer 
{ 
    // ... 
    // 默认每10秒更新一次的时钟缓存， 
    // 用于计算键的空转（idle）时长。
    unsigned lruclock:22;
    //...
};
```

每个Redis对象都会有一个lru属性，这个lru属性保存了对象最后一次被命令访问的时间：

```c
typedef struct redisObject 
{ 
    // ... 
    unsigned lru:22; 
    // ...
} robj;
```

当服务器要**计算一个数据库键的空转时间**（也即是数据库键对应的值对象的空转时间），程序会用服务器的lruclock属性记录的时间减去对象的lru属性记录的时间。

由于是10秒更新一次，所以时钟并不是实时的，这个LRU时间只是一个模糊的估算值。

### 14.2.3 更新服务器每秒执行命令次数

`serverCron`函数中的`trackOperationsPerSecond`函数会以每100毫秒一次的频率执行，这个函数的功能是以**抽样**计算的方式，**估算并记录服务器在最近一秒钟处理的命令请求数量**。

`trackOperationsPerSecond`函数每次运行，都会根据`ops_sec_last_sample_time`记录的上一次抽样时间和服务器的当前时间，以及`ops_sec_last_sample_ops`**记录的上一次抽样的已执行命令数量和服务器当前的已执行命令数量**，计算出两次`trackOperationsPerSecond`调用之间，服务器**平均每一毫秒处理了多少个命令请求，然后将这个平均值乘以1000，这就得到了服务器在一秒钟内能处理多少个命令请求的估计值**，这个估计值会被作为一个新的数组项被放进`ops_sec_samples`环形数组里面。

### 14.2.4 更新服务器内存峰值记录

服务器状态中的`stat_peak_memory`属性记录了服务器的内存峰值大小：

```c
struct redisServer 
{ 
    // ... 
    // 已使用内存峰值 
    size_t stat_peak_memory; 
    // ...
};
```

每次serverCron函数执行时，**程序都会查看服务器当前使用的内存数量，并与stat_peak_memory保存的数值进行比较**，如果当前使用的内存数量比stat_peak_memory属性记录的值要大，那么就替换峰值。

### 14.2.5 处理SIGTERM信号

在启动服务器时，Redis会为服务器进程的SIGTERM信号关联处理器`sigtermHandler`函数，这个信号处理器负责在服务器**接到SIGTERM信号时，打开服务器状态的shutdown_asap标识**。

每次serverCron函数运行时，程序都会对服务器状态的shutdown_asap属性进行检查，并**根据属性的值决定是否关闭服务器**。

### 14.2.6 管理客户端资源

serverCron函数每次执行都会调用clientsCron函数，检查：

- 客户端服务器连接超时（长时间没有互动），程序将释放这个客户端。
- 客户端在上一次执行命令后，输入缓冲区大小超过一定长度，程序会释放客户端当前的输入缓冲区。

### 14.2.7 管理数据库资源

serverCron函数每次执行都会调用databasesCron函数，这个函数会对服务器中的一部分数据库进行检查，删除其中的过期键，并在有需要时，对字典进行收缩操作。参见Redis中的定期检查

### 14.2.8 执行被延迟的BGREWRITEAOF

在服务器执行BGSAVE命令的期间，如果客户端向服务器发来BGREWRITEAOF命令，那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后。

每次serverCron函数执行时，函数都会检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行，如果这两个命令都没在执行，且有被延迟的BGREWRITEAOF，则执行。

### 14.2.9 检查持久化操作的运行状态

![img](https://camo.githubusercontent.com/4c916965feb88bc1fca4a2c2979f219b14a87f9826a0153f5ceacede1563da9d/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130373131333935322e706e67)



### 14.2.10 将AOF缓冲区的内容写入AOF文件

### 14.2.11 关闭异步客户端

### 14.2.12 增加cronloops计数

服务器状态的cronloops属性记录了serverCron函数执行的次数，每执行一次就增加计数。作用是：在**复制模块**中实现“**每执行serverCron函数N次就执行一次指定代码**”的功能。

## 14.3 初始化服务器

服务器初始化要完成以下几个任务：

- 初始化服务器状态结构
- 载入配置选项
- 初始化服务器数据结构
- 还原数据库状态
- 执行时间循环

### 14.3.1 初始化服务器状态结构

创建一个`struct redisServer`类型的实例变量`server`作为服务器的状态，并为结构中的各个属性设置默认值。

初始化server变量的工作由`redis.c/initServerConfig`函数完成，主要工作：

- 设置服务器ID
- 设置服务器运行默认频率
- 设置配置文件路径
- 设置运行架构
- 设置默认端口号
- 设置RDB持久化和AOF持久化条件
- 初始化LRU时钟
- 创建命令表

### 14.3.2 载入配置选项

完成初始化服务器状态结构后，所有变量会被附上默认的值，但是实际上用户可能修改了某些参数。此时，载入用户的配置选项，**替换掉那些被修改后的默认值**。

### 14.3.3 初始化服务器数据结构

除了在之前执行`initServerConfig`函数初始化server状态时，程序只创建了命令表一个数据结构，在这个阶段还需要创建其他数据结构，服务器通过调用 `initServer`函数负责初始化数据结构：

- `server.client`链表，记录了所有与服务器相连的客户端状态结构。
- `server.db`数组，数组中包含了所有数据库。
- `server.pubsub_channels`字典，保存模式订阅信息的`server.pubsub_patterns`链表。
- `server.lua`，用于执行Lua脚本的Lua环境
- `server.slowlog`，用于保存慢查询日志。

服务器到现在才初始化数据结构的原因在于，服务器**必须先载入用户指定的配置选项，然后才能正确地对数据结构进行初始化**。

除了以上的数据结构，还有

- 进程信号处理器
- 创建共享对象
- 打开服务器的监听窗口
- 为serverCron函数创建时间事件
- 为AOF写入做好准备
- 初始化后台IO模块（bio）

### 14.3.4 还原数据库状态

在完成了对服务器状态server变量的初始化之后，服务器需要载入RDB文件或者AOF文件，并根据文件记录的内容来还原服务器的数据库状态。

如果启用了AOF持久化功能，则会使用AOF来还原，否则用RDB文件还原。

### 14.3.5 执行事件循环

在初始化的最后一步，服务器将打印出以下日志：

```tex
[5244] 21 Nov 22:43:49.084 * The server is now ready to accept connections on port 6379
```

并开始执行事件循环，意味着服务器现在开始可以接受客户端的连接请求了。















