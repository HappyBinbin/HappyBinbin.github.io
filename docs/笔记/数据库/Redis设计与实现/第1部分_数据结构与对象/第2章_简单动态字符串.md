# 2.简单动态字符串

Redis 没有直接使用C语言传统的字符串表示，即以空白符号('\0')结尾的字符数组，而是d自己构建了一种简单动态字符串（Simple Dynamic String) SDS。在Redis里面，只有一些无需对字符串进行修改的地方才会使用C字符串，其他默认使用SDS。SDS除了用来保存数据库中的字符串，也被用来做缓冲区，例如：AOF模块缓冲区、客户端的输入、输出缓冲区。

## 2.1 SDS 的定义

SDS是一个结构体，定义在`sds.h/sdshdr`中

```c
struct sdshdr {
    // 记录 buf 数组中已使用字节的数量
    // 等于 SDS 所保存字符串的长度
    int len;
    // 记录 buf 数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
};
```

下面给出了一个示例，free为0代表所有空间都被使用，len长度为5，表示SDS保存的字符串长度为5，buf就是字符串实体。

![img](https://camo.githubusercontent.com/fb1447134ce6820302bbb78a25c2d2b6541b052293adbc65936444f691532c6e/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130323131303534312e706e67)

保存空字符的1字节空间**不计算在len属性内**。遵循空字符结尾这一惯例的好处是， SDS 可以直接重用一部分 C 字符串函数库里面的函数。

比如我们不需要对SDS专门设置打印函数。

```
printf("%s",s->buf);
```

## 2.2 SDS 与 C 字符串的区别

### 2.2.1 常数复杂度获取字符串长度

我们知道，获取C字符串的长度时，需要遍历整个字符串来统计长度，时间复杂度为O（n），而 SDS 记录了len，即它可以以O（1）的时间复杂度获取字符串长度，使得获取字符串长度的工作不会成为Redis的性能瓶颈。

### 2.2.2 杜绝缓冲区溢出

由于C字符串不记录长度，当我们拼接两个字符串的时候，容器可能**因为空间不足发生溢出**。Redis中的`sdscat（）函数`将在执行拼接操作前**检查长度是否充足**，若不足则先拓展空间，再拼接。

### 2.2.3 减少修改字符串时带来的内存重分配次数

#### 1. 空间预分配

C字符串类似于数组，每次修改大小都会重新分配以此内存。Redis的分配原理类似于`std::vector`，通过**空间预分配**的办法**优化字符串增加**，分配规则如下：

- 若len比较小（小于1MB），则free是len一样大。如果修改后len为13字节，则free也为13字节，buf实际长度为13+13+1=27字节。（空字符为额外的1字节）
- 若len比较大（大于1MB），则每次free只会有1MB，比如修改后len为30MB，则free为1MB，总长度为30MB+1MB+1byte

#### 2. 惰性空间释放

使用**惰性空间释放来优化字符串缩短**。当缩短时，将释放的空间放入free中保存起来，等待使用。即多余的空间会被free给控制保存起来，以便需要的时候进行分配。SDS也提供了真正释放未使用空间的API，所以不用担心惰性空间释放策略会造成内存浪费。

### 2.2.4 二进制安全

C字符串以空字符`\0`结尾，并且其字符必须符合某种编码（如ASCII），这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

虽然数据库一般保存文本数据，较少保存二进制数据，但是为了使得数据库能够适用于不同的场景，SDS的API都是二进制安全的。

SDS.buf （字节数组）是用来保存一系列二进制数据的，而不是保存字符的。并且，SDS利用len来判断是否结束，而不是空字符`\0`，所以不怕遇到以 `\0`为分割符的单词

![img](https://camo.githubusercontent.com/c3bdc899e259fdc2f535123acc468143575a71a0dda44cccb703764e58114ecd/68747470733a2f2f6275636b65742d313235393535353837302e636f732e61702d6368656e6764752e6d7971636c6f75642e636f6d2f32303230303130323131333435382e706e67)

### 2.2.5 兼容部分C字符串函数

这个因为SDS一样遵循`\0`结尾，所以有部分C字符串的函数还是可以用的。

### 2.2.6 小结

| C字符串                          | SDS                                |
| -------------------------------- | ---------------------------------- |
| 获取长度的复杂度O(N)             | O(1)                               |
| API不安全，缓冲区溢出            | API安全，不会缓冲区溢出            |
| 修改字符串长度必然导致内存重分配 | 修改字符串长度不一定导致内存重分配 |
| 只能保存文本数据                 | 可以保存文本或二进制数据           |
| 可使用所有<string.h>库的函数     | 可使用部分<string.h>库的函数       |

## 2.3 SDS API

| 函数        | 作用                                                       | 时间复杂度     |
| ----------- | ---------------------------------------------------------- | -------------- |
| sdsnew      | 创建一个包含给定C字符串的SDS                               | O(N)           |
| sdsempty    | 创建一个不包含任何内容的SDS                                | O(1)           |
| sdsfree     | 释放SDS                                                    | O(N)           |
| sdslen      | 返回SDS已使用的字节数                                      | O(1)           |
| sdsavail    | 返回SDS未使用的字节数                                      | O(1)           |
| sdsdup      | 创建一个给定SDS的副本                                      | O(N)           |
| sdsclear    | 清空SDS保存的字符串内容                                    | O(1)，惰性释放 |
| sdscat      | 将给定C字符串拼接到SDS字符串的末尾                         | O(N)           |
| sdscatsds   | 将给定SDS字符串拼接到另一个SDS的末尾                       | O(N)           |
| sdscpy      | 复制                                                       | O(N)           |
| sdsgrowzero | 用空字符将SDS扩展至给定长度                                | O(N)           |
| sdsrange    | 保留SDS给定区间内的数据，不在区间内的数据会被覆盖或清除    | O(N)           |
| sdstrim     | 接受一个SDS和C字符为参数，从SDS中移除C字符串中出现过的字符 | O(N^2)         |
| sdscmp      | 比较                                                       | O(N)           |























