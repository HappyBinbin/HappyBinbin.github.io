# 第三章 运输层

## 3.1 概述和运输层服务

运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信。

##### 报文段

将运输层分组称为报文段

 - 对于TCP分组也称为报文段
 - 对于UDP分组常称为数据报

##### TCP和UDP的最基本责任

将两个端系统间IP的交付服务拓展为运行在端系统上的两个进程之间的交付服务。

## 3.2 多路复用和多路分解

将主机间交付拓展到进程间交付被称为运输层的多路复用和多路分解
一个进程有一个或多个套接字，每一个都有唯一的标识符。接收端运输层检查报文段的字段，标识出接受套接字，进而将报文定向到正确的套接字。

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210526231620472.png" alt="image-20210526231620472" style="zoom: 67%;" />

##### 多路分解

将运输层报文段中的书交付到正确的套接字的工作称之为多路分解

##### 多路复用

发送端从不同的套接字中收集数据块，并为它们封装上首部字段生成报文段后，交付给网络层的过程称之为多路复用

##### 多路复用的要求

- 套接字有唯一标识符
- 每个报文段有特殊字段来显示该报文段要交付到的套接字

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527094735485.png" alt="image-20210527094735485" style="zoom: 67%;" />

##### 端口号范围

- 周知端口号：0~1023，保存为熟知的应用层协议使用
- 其他端口号：1024~65535

##### 无连接的多路复用和多路分解

​	 一个 UDP 套接字是由一个二元组全面标识的，该二元组包含一个目的1P 地址和一个目的端口号 。因此•如果两个 UDP 报文段有不同的源 1P 地址和 / 或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程 。

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527095756126.png" alt="image-20210527095756126" style="zoom: 50%;" />



##### 面向连接的多路复用和多路分解

 TCP 套接字是由一个四元组 （ 源 IP 地址，源端口号 ，目的 IP 地址 ，目的端口号 ） 来标识的 。因此 ，当一个 TCP 报文段从网络到达一台主机时，该主机使用全部 4 个值来将报文段定向 （ 分解 ） 到相应的套接字 。特别与UDP 不同的是，两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字，除非 TCP 报文段携带了初始创建连接的请求 。

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527102525078.png" alt="image-20210527102525078" style="zoom:50%;" />

## 3.3 UDP

TCP比UDP更加可靠，为什么不所有的应用都首选TCP呢？因为许多应用更适合UDP

-  关于发送什么数据以及何时发送的应用层控制更为精细
-  无须连接建立 
-  无连接状态 
-  分组首部开销小

![image-20210408220530213](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/20210408220530.png)

##### 端到端原则

在既无法确保逐链路的可靠性，又无法确保内存中的差错检测的情况下，如果端到端数据
传输服务要提供差错检测，UDP 就必须在端到端基础上在运输层提供差错检测 。这是一个在系统设计中被称颂的端到端原则 （ end-end principle）

## 3.4 可靠数据传输原理

​	为上层实体提供的服务抽象是 ： 数据可以通过一条可靠的信道进行传输 。借助于可靠信道，传输数据比特就不会受到损坏（ 由 0 变为 1, 或者相反 ） 或丢失，而且所有数据都是按照其发送顺序进行交付 。

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527105934374.png" alt="image-20210527105934374" style="zoom:50%;" />

### 构造可靠数据传输协议

有限状态机 ( Finite-StateMachine , FSM）

- 引起变迁的事件显示在表示变迁的横线上方，事件发生时所采取的动作显示在横线下方 。
- 如果对一个事件没有动作,或没有就事件发生而采取了一个动作 ，我们将在横线上方或下方使用符号 A, 以分别明确地表示缺少动作或事件。
- FSM 的初始状态用虚线表示。



#### rdt 1.0

经完全可靠信道的可靠数据传输

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527110829598.png" alt="image-20210527110829598" style="zoom:50%;" />

**发送端：**

rdt 的发送端只通过 rdt_send(data) 事件接受来自较高层的数据 ，产生一个包含该数据
的分组(经由 make-pkt (data) 动作)，并将分组发送到信道中 。实际上，rdt_send(data) 事件是由较高层应用的过程调用产生的(例如 ，rdt_send() ) 

**接收端：**

在接收端 ，rdt 通过皿 rdt_rcv( packet) 事件从底层信道接收一个分组，从分组中取岀数据(经由 extract ( packet , data ) 动作)，并将数据上传给较高层(通过 deliver_data( dat3 ) 动作) 。实际上，rdt_rcv( packet) 事件是由较低层协议的过程调用产生的(例如，rdt_rcv( ))



#### rdt 2.0

经具有比特差错信道的可靠数据传输

##### 自动重传请求协议

控制报文使得接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误并因此需要重复 。在计算机网络环境中，基于这样重传机制的可靠数据传输协议称为自动重传请求
( Automatic Repeat reQuest , ARQ) 协议 

 ARQ 协议中还需要另外三种协议功能来处理存在比特差错的情况 ：

- 差错检测，校验和字段， 这些比特将被汇集在rdt 2.0 数据分组的分组检验和字段中 
- 接收方反馈， 在口述报文情况下回答的“ 肯定确认 ”( ACK)和“ 否定确认 ”(NAK) 就是这种反馈的例子。rdt 2.0 协议将从接收方向发送方回送 ACK 与 NAK 分组 。如用 0 表示 NAK, 用 1 表示 ACK 
- 重传，收到有差错的分组时，发送方将重传该分组报文

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527111756640.png" alt="image-20210527111756640" style="zoom: 67%;" />

**发送端：**

- 等待来自上层的调用状态
- 等待ACK或NACK，如果收到一个ACK分组，则已知分组被正确接收，协议返回到等待来自商城的数据的状态；如果收到一个NAK分组，则需要重传上一个分组并等待接受方为响应重传分组而会送的ACK或NAK

当发送方处于等待ACK 或 NAK 的状态时，它不能从上层获得更多的数据；这就是说，rdcsend () 事件不可能岀现；仅当接收到 ACK 并离开该状态时才能发生这样的事件。因此 ，发送方将不会发送一块新数据 ，除非发送方确信接收方已正确接收当前分组 。由于这种行为 ，rdt2.0 这样的协议被称为**停等 ( stop-and-wait) 协议** 

**接受端：**

单一的状态， 当分组到达时，接收方要么回答一个 ACK, 要么回答 一个 NAK, 这取决于收到的分组是否受损 。

**缺陷**

​	没有考虑到ACK和NAK分组受损的情况，如果它们出错了，则无法知道接收方是否正确接收了上一块发送的数据

#### rdt 2.1

​	在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的序号(sequence number) 放在该字段。

rdt2. 1 的发送方和接收方 FSM 的状态数都是以前的两倍 。这是因为协议状态此时必须反映出目前 （ 由发送方 ） 正发送的分组或 （ 在接收方 ） 希望接收的分组的序号是 0 还是 1 。值得注意的是，发送或期望接收 0 号分组的状态中的动作与发送或期望接收 1 号分组的状态中的动作是相似的 ； 唯一的不同是序号处理的方法不同 

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527115126272.png" alt="image-20210527115126272" style="zoom: 67%;" />

![image-20210527160340402](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527160340402.png)

#### rdt 2.2

​	发送方接收到对同一个分组的两个 ACK（ 即接收冗余 ACK（duplicate ACK））后 ，就知道接收方没有正确接收到跟在被确认两次的分组后面的分组

rdt2.2 是在有比特差错信道上实现的一个无 NAK 的可靠数据传输协议

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527160640744.png" alt="image-20210527160640744" style="zoom: 67%;" />

​	接收方此时必须包括由一个 ACK 报文所确认的分组序号(这可以通过在接收方 FSM 中，在 make_pkt () 中包括参数 ACK 0 或ACK1 来实现)，发送方此时必须检查接收到的ACK 报文中被确认的分组序号(这可通过在发送方 FSM 中，在 isACK() 中包括参数 0 或 1 来实现) 

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527160718878.png" alt="image-20210527160718878" style="zoom: 67%;" />

#### rdt 3.0

经具有比特差错的丢包信道的可靠数据传输，rdt3.0

如果除了比特差错外，信道还会丢包

- 怎样检测丢包以及发生丢包后应该怎么处理？
- 如何使用检验和、序号、ACK分组和重传（rdt2.0已经解决）

解决方法

发送方的功能：

1. 每发送一个分组（包括第一次分组和重传分组）时，便启动一个定时器
2. 响应定时器中断（采取适当的动作）
3. 终止定时器

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527162120249.png" alt="image-20210527162120249" style="zoom:50%;" />

##### 比特交替协议

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527162330295.png" alt="image-20210527162330295" style="zoom:50%;" /><img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527162405418.png" alt="image-20210527162405418" style="zoom:50%;" />

##### 总结

​	一个可靠的传输协议，检验和、序号、定时器、肯定和否定确定分组这些技术是必不可少的

### 流水线可靠数据传输协议

​	即使 rdt3.0 能是一个功能正常的协议，但是它对信道的利用率非常低。

假设两个端系统之间的光速往返传播时延 RTT 大约为 30 毫秒 ，假定彼此通过一条发送速率 R 为 1 Gbps （ 每秒 10^9比特 ） 的信道相连 。包括首部字段和数据的分组长 L 为1000 字节 （ 8000 比特 ），发送一个
分组进入 1 Gbps 链路实际所需时间是 

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527163547048.png" alt="image-20210527163547048" style="zoom:50%;" />

##### 对于停等协议：

- 分组进入发送信耗费的时间为：0.008 ms
- 最后一个比特到达接收端耗费的时间为：15 ms
- 接收方返回一个ACK的耗费时间为（假设ACK分组很小，可以忽略）：15 ms

则一共话费 30.008 ms，而发送信道的实际利用率为

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527163927895.png" alt="image-20210527163927895" style="zoom:50%;" />

并且我们还忽略了中间路由器的各种时延，如果加上，则性能会更糟糕

##### 对于流水线协议

​	无需等待ACK，允许发送方发送多个分组而无需等待确认

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527164353649.png" alt="image-20210527164353649" style="zoom:50%;" />

如果要增加流水线技术，则协议需要改进

- 增加序号范围，因为每个输送中的分组（不计算重传的）都必须有一个唯一的序号，而且也许有多个在输送中的未确认报文
- 协议的发送方和接收方两端也许得不得缓存多个分组。发送方最低限度应当能缓存那些已经发送但没有确认的分组；接收方或许也需要缓存那些已经正确接收的分组。
- 所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。解决流水线的差错恢复有两种方法，回退N步、选择重传

### 回退N步（GBR）

允许发送多个分组而不用等待确认，但也受限于未确认分组数不能超过最大允许数N。

我们将基序号 （ base ） 定义为最早未确认分组的序号，将下一个序号 （ nextseqnum ） 定义为最小的未使用序号 （ 即下一个待发分组的序号 ），则可将序号范围分割成 4 段 。在 ［ 0, base - 1 ］ 段内的序号对应于已经发送并被确认的分组［base, nextseqnum - 1］ 段内对应已经发送但未被确认的分组 。［ nextseqnum , base + N - 1 ］ 段内的序号能用于那些要被立即发送的分组，如果有数据来自上层的话 。最后，大于或等于 base + N 的序号是不能使用的，直到当前流水线中未被确认的分组 （ 特别是序号为 base 的分组 ） 已得到确认为止。

N 常被称为窗口长度，GBN协议也常被称为滑动窗口协议

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527193635904.png" alt="image-20210527193635904" style="zoom:50%;" />

一个分组的序号承载在分组首部的一个固定长度的字段中，这个字段的比特数如果是k，那么序号的范围就是[1,2^(k-1)]

#### 发送方

必须响应三种类型的事件：

1. 上层的调用，当上层调用 rdt_send()时，先检查窗口是否已满，即是否有N个已发送但未被确认的分组。如果窗口未满，则产生一个分组将其发送，并更新变量。如果窗口已满，则将数据返回给上层，隐式地通知上层窗口已满，来取数据
2. 收到一个ACK，对序号为n的分组确认采用累计确认的方式，表明已经收到序号为n的以前且包括n在内的所有分组
3. 超时事件，如果出现超时，发送方重传所有已发送但还未被确认过的分组 

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527194043820.png" alt="image-20210527194043820" style="zoom:50%;" />

#### 接收方

会丢弃所有失序的分组，这样做的优点是接受缓存简单，但是会造成分组重传的资源浪费

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527194100831.png" alt="image-20210527194100831" style="zoom:50%;" />

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527194851797.png" alt="image-20210527194851797" style="zoom: 67%;" />

### 选择重传（SR）

​	通过让发送方仅重传哪些它怀疑在接收方出错（丢失或受损）的分组而避免了必要的重传。

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527195556387.png" alt="image-20210527195556387" style="zoom:50%;" />

#### 发送方

- 滑动窗口基序号，也就是左边界，一定是具有最小序号的未确认分组处

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527195750669.png" alt="image-20210527195750669"  />

#### 接收方

- 接收方将确认一个正确接收的分组而不管其是否按序，失序的分组会被缓存直到所有丢失分组（序号更小的分组）都被接收到为止

![image-20210527195825466](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527195825466.png)

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527201043994.png" alt="image-20210527201043994" style="zoom: 67%;" />

#### SR协议的缺陷

由于序号是有限的（为了进行流量控制），发送方和接收方窗口间缺乏同步会产生严重的后果

- 当接收方的窗口长度只比序号空间小1时，协议无法工作，序号是循环利用的，因此无法判断是前一组的重传还是新组的包
- 因此，窗口长度必须小于等于空间大小的一半

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527201359612.png" alt="image-20210527201359612" style="zoom:67%;" />

### 可靠传输机制的总结

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527201940741.png" alt="image-20210527201940741" style="zoom:67%;" />

## 3.5 TCP

> 多播：在一次发送操作中，从一个发送方将数据传送给多个接收方【看到了就介绍一下】

TCP的特点：

- 面向连接
- 全双工服务，点对点

##### 最大传输单元

Maximum Transmission Unit， MTU，也叫最大链路层帧长度，以太网和PPP链路层协议都具有1500字节的MTU

##### 最大报文段长度

Maximum Segment Size，MSS，是指在报文段里应用层数据的最大长度，而不是值包括首部的TCP报文段的最大长度。取决于MTU的大小，一般除去TCP/IP首部（通常40字节）之后，MSS典型值为1460字节

##### 路径MTU

​	从源到目的地的所有链路上发送的最大链路层帧

TCP连接的组成：一台主机上的缓存、变量和与进程连接的套接字、另一台主机上的另一组存、变量和与进程连接的套接字，与两台主机之间的网络元素（路由器、交换机）无关，它们只负责传输数据包<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527205123302.png" alt="image-20210527205123302" style="zoom:50%;" />

### 报文结构

​	前述可知，MSS限制了报文段的数据字段的最大长度。当TCP发送一个大文件时，会将文件划分成长度为MSS的若干块（最后一块除外，通常它小于MSS）

![image-20210408220508813](https://gitee.com/HappyBinbin/pcigo/raw/master/pic/20210408220516.png)

#### 序号和确认号

一个报文段的序号是该报文段首字节的字节流编号

- 采用累积确认
- 采用选择重传，不丢弃失序的字节

 假定数据流由一个包含 500 000 字节的文件组成，其 MSS 为 1000字节，数据流的首字节编号是 0。如图 3-30所示，该 TCP 将为该数据流构建 500 个报文段 。给第一个报文段分配序号 0，第二个报文段分配序号 1000，第三个报文段分配序号 2000，以此类推。每一个序号被填入到相应 TCP报文段首部的序号字段中

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210527211825491.png" alt="image-20210527211825491" style="zoom:50%;" />

##### 捎带

对客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中

### 往返时间的估计与超时

- 超时时间一定要比RTT大，才不会造成不必要的重传浪费
- RTT到底应该设置成多大合适呢？
- 刚开始应该如何估计RTT呢？
- 是否未所有未确认的报文段各设一个计时器？
    - 采用单一重传定时器，即使有多个已发送但未确认的报文段。

#### 估计往返时间

报文段的样本RTT（Sample RTT）就是从某报文段被发出（交给IP）到对该报文段的确认被收到之间的时间量。

- 大多数的TCP的实现仅在某个时刻做一次SampleRTT测量
- 决不为已被重传的报文段计算Sample RTT

由于路由器的拥塞和端系统负载的变化，报文段的SampleRTT值会随之波动，这种波动会造成SampleRTT的不稳定。所以采用某个取平均值的方法，TCP维持一个SampleRTT的均值，一旦获得一个新的SampleRTT时，TCP就会根据以下公式来更新EstimateRTT（α一般为：0.125）：

![image-20210528100825465](https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210528100825465.png)

#### 设置和管理重传超时间隔

也就是说，超时时间间隔应该大于等于EstimateRTT，否则就会造成不必要的重传；但是也不能大太多，否则不能很快地进行重传也会导致数据传输时延加大

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210528101417209.png" alt="image-20210528101417209" style="zoom:50%;" />

###  可靠数据传输

​	TCP能够确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流

#### 高度简化版TCP发送方

```c
/* 假设发送方不受 TCP 流量和拥塞控制的限制，来自上层数据的长度小于 MSS, 且数据传送只在一个
方向进行 。*/ .
    NextSeqNum=InitialSeqNumber
    SendBase=InitialSeqNumber
    loop （ 永远 ） {
        switch （ 事件 ）
            事件:从上面应用程序接收到数据 e
                生成具有序号 NextSeqNum 的 TCP 报文段
                if （ 定时器当前没有运行 ）
                    启动定时器
                    向 IP 传递报文段
                        I NextSeqNum=NextSeqNum+length （ data ）
                        break;
            事件 ： 定时器超时
                重传具有最小序号但仍未应答的报文段
                启动定时器
                break;
            事件 ： 收到 ACK, 具有 ACK 字段值 y
                if （ y > SendBase ）{
                    SendBase=y
                        if （ 当前仍无任何应答报文段 ）
                            启动定时器
                        }
    	   break;
    } /* 结束永远循环 */
```

#### 超时间隔加倍

​	TCP重传具有最小序号的还未被确认的报文段，每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，即超时间隔在每次重传后会呈指数型增长

#### 快速重传

​	如果发送放接收到对相同数据的3个冗余ACK，就说明在这个已被确认过3次的报文段之后的报文段已经丢失，那么TCP就执行快速重传，而不必等待定时器到了再重传

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210528114428918.png" alt="image-20210528114428918" style="zoom:50%;" />

#### GBN or SR

​	两种都不是很贴合TCP，所以提出了一种修改意见，就是所谓的**选择确认**，允许TCP接收方有选择地确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。当该机制与选择重传结合起来使用时（跳过重传那些已经被接收方选择性地确认过的报文段）

### 流量控制

​	TCP为应用程序提供了**流量控制服务，**以消除发送方使接收方缓存溢出的可能性。TCP发送方也可能应为IP网络的拥塞而被遏制，这种形式的发送方的控制被称为**拥塞控制**

TCP让发送方和接收方都维护一个“接收窗口”（因为是全双工），在传输时通过对该窗口的控制来进行流量控制。

假设主机 A 通过一条 TCP 连接向主机 B 发送一个大文件 。主机 B 为该连接分配了一个接收缓存，并用 RcvBuffer 来表示其大小 。 主机 B 上的应用进程不时地从该缓存中读取数据 。我们定义以下变量：

- LastByteRead : 主机 B 上的应用进程从缓存读出的数据流的最后一个字节的编号 
- LastByteRcvd : 从网络中到达的并且已放入主机 B 接收缓存中的数据流的最后一个字节的编号

由于 TCP 不允许已分配的缓存溢岀，下式必须成立:

`LastByteRcvd - LastByteRead RcvBuffer`

接收窗口用 rwnd 表示，根据缓存可用空间的数量来设置：

`rwnd = RcvBuffer - [ LastByteRcvd - LastByteRead ]`

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210528114925274.png" alt="image-20210528114925274" style="zoom:50%;" />

主机 B 通过把当前的rwnd 值放入它发给主机 A 的报文段接收窗口字段中，通知主机 A 它在该连接的缓存中还有多少可用空间，开始时，主机 B设定 rwnd = RcvBuffer

主机 A 轮流跟踪两个变量，LastByteSent 和 LastByteAcked , 这两个变量的意义很明显 。注意到这两个变量之间的差 LastByteSent - LastByteAcked , 就是主机 A 发送到连接中但未被确认的数据量 。通过将未确认的数据量控制在值 rwnd 以内，就可以保证主机 A 不会使主机 B 的接收缓存溢出 。因此，主机 A 在该连接的整个生命周期须保证：`LastByteSent 一 LastByteAcked ≤ rwnd`

 事实上，TCP 仅当在它有数据或有确认要发时才会发送报文段给主机 A，所以当主机 B 的 rwnd 为 0 时， 主机 A 不可能知道主机 B 的接收缓存已经有新的空间了，即主机 A 被阻塞而不能再发送数据 ！ 为了解决这个问题，TCP 规范中要求 ： 

> 当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段 。这些报文段将会被接收方确认 。最终缓存将开始清空，并且确认报文里将包含一个非 0 的rwnd 值 

### TCP 连接管理

#### 三次握手

客户首先发送一个特殊的 TCP 报文段，服务器用另一个特殊的 TCP 报文段来响应，最后，客户再用第三个特殊报文段作为响应 。前两个报文段不承载 “ 有效载荷 ”，也就是不包含应用层数据 ； **而第三个报文段可以承载有效载荷。**由于在这两台主机之间发送了 3 个报文段，所以这种连接建立过程常被称为三次握手（ three- way handshake ）

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210528200823634.png" alt="image-20210528200823634" style="zoom:50%;" />

#### 四次挥手

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210528200850276.png" alt="image-20210528200850276" style="zoom:50%;" />

#### 洪泛攻击

​	黑客发送大量的请求给服务器，服务器创建大量的连接，但是客户端不进行第三次握手，造成服务器的大量连接处于半连接状态，需等待（通常）1分多钟之后服务器才会断开连接并挥手资源。这样会造成服务器连接资源消耗殆尽。

##### SYN Cookie：

- 服务器不会为第一个SYN报文段生成一个半开连接 。 相反 ， 服务器生成一个初始 TCP 序列号 ， 该序列号是 SYN 报文段的源和目的 IP 地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数 （ 散列函数 ） 。 这种精心制作的初始序列号被称为 “ cookie ” 。 服务器则发送具有这种特殊初始序列号的 SYNACK 分组 。 重要的是 ， 服务器并不记忆该 cookie 或任何对应于 SYN 的其他状态信息
- 如何客户是合法的，返回一个SYNACK，服务器则将使用在 SYNACK 报文段中的源和目的地 IP 地址与端口号 （ 它们与初始的 SYN 中的相同 ） 以及秘密数运行相同的散列函数 。 如果该函数的结果加 1 与在客户的SYNACK 中的确认 （ cookie ） 值相同的话 ， 服务器认为该 ACK 对应于较早的SYN 报文段 ， 因此它是合法的 。 服务器则生成一个具有套接字的全开的连接 
-  如果客户没有返回一个 ACK 报文段 ， 则初始的 SYN 并没有对服务
    器产生危害 ， 因为服务器没有为它分配任何资源 

## 3.6 拥塞控制原理

### 情况1：

两个发送方和一台具有无穷大缓存的路由器

> 当分组的到达速率接近链路容量时，分组经历巨大的排队时延

### 情况2：

两个发送方和一台具有有限缓存的路由器

> - 发送方必须执行重传以补偿因为缓存溢出而丢弃的分组
> - 发送方在遇到大延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本

### 情况3：

四个发送方和具有有限缓存的多态路由器及多跳路径

> 当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了；即当有一个分组在第二跳路由器上被丢弃时，第一跳路由器所做的将分组转发到第二跳路由器的工作就是“劳而无功”的

### 控制方法

IP层不向端系统提供显式的网络拥塞反馈

1. 端到端拥塞控制：端系统要通过对网络行为的观察来推断拥塞情况
2. 网络辅助的拥塞控制
    - 经由接收方的网络反馈
    - 直接网络反馈

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210529112522158.png" alt="image-20210529112522158" style="zoom:50%;" />

## 3.7 TCP 拥塞控制

TCP 必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制，因为IP不向端系统提供显式的网络拥塞反馈。

1. 一个TCP发送方如何限制它向其连接发送流量的速率呢？
    - 一个发送方中未被确认的数据量不会超过 min{cwnd，rwnd}，假设接受缓存足够大，则发送方中未被确认的数据量仅受限于cwnd，通过调节cwnd的值，就可以调整它向连接发送数据的速率
2. 一个TCP发送方如何感知从它到目的地之间的路径上存在拥塞呢？
    - 要么出现超时，要么收到来自接收方的3个冗余ACK
3. 当发送方感知到端到端的拥塞时，采用什么算法来改变其发送速率呢？
    - 一个丢失的报文段意味着拥塞，应当降低TCP发送方的速率
    - 一个确认报文段指示网络正在向接收方交付报文段，所以能够增加发送方的速率
    - 带宽探测

### TCP 拥塞控制算法

- 慢启动
- 快重传
- 拥塞避免
- 快恢复

注意：

- 出现网络阻塞时才将 ssthresh 降为一个MSS
- 出现超时或者三个冗余ACK时，才将 ssthresh 降为一半

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210529150548666.png" alt="image-20210529150548666" style="zoom:50%;" />

<img src="https://gitee.com/HappyBinbin/pcigo/raw/master/image-20210529150600072.png" alt="image-20210529150600072" style="zoom:50%;" />

## 3.8 小结

​	















































































